#ifdef FCA_REF_MOD
module displace_wrf_tl_m
!$$$ module documentation block
!           .      .    .                                       .
! module:   displace_wrf_tl_m
!  prgmmr: Nehrkorn
!
! abstract: Horizontally displace WRF model fields, tangent-linear (TL) version
!
! program history log:
!
! subroutines included:
!   sub displace_wrf_fields_tl
!   sub calc_ph_hyd_wrf_tl
!   sub adj_wrf_derived_tl
!   sub displace_theta_wrf_tl
!   sub apply_disp_theta_tl
!
! functions included:
!   sh2rh_tl
!   rh2sh_tl
!
! variable definition:
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
  use kinds, only: r_kind, i_kind
  use core_disp_types_m, only: fca_gridded_disp, ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte
  use core_disp_func_tl_m, only: apply_disp_2d_tl, apply_vert_tl
  use displace_wrf_m, only: t0, p0, gas_constant, gas_constant_v, gravity, grav, Rd, Rv, cp, kappa, base_pres, gamma

  implicit none
  private
  public :: displace_wrf_fields_tl
contains
#else
#define TRACE_USE
#endif

SUBROUTINE DISPLACE_WRF_FIELDS_TL(th_compute, istep, qv_ind, moist, nmoist, moist_tl &
       , p, p_tl, pb, t, t_tl, ph, ph_tl, phb, u, u_tl, v, v_tl, w, w_tl, &
       hgt, mub, mu, mu_tl, psfc, psfc_tl, znu, znw, c1h, c2h, c3h, c4h, c3f, c4f, ptop, fcadisp, fcadisp_tl, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: displace_wrf_fields_tl
!   prgmmr: Nehrkorn
!
! abstract: Horizontally displace WRF model fields
!
! program history log:
!
!   input argument list: 
!      th_compute				! control parameter for theta computation/displacemnt
!      istep				! control parameter for theta computation/displacemnt
!      qv_ind				! index for qvapor
!      nmoist ! number of moisture fields
!      p, pb, t, u, v, w
!      ph, phb, ph_tl
!      p_tl, t_tl, u_tl, v_tl, w_tl
!      moist
!      moist_tl
!      hgt, mub
!      mu, psfc
!      mu_tl, psfc_tl
!      znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
!      ptop
!      fcadisp			! displacement field generated by FCA routine
!      fcadisp_tl		! displacement field generated by FCA routine
!      interp_order
!
!   output argument list:
!      p, pb, t, u, v, w
!      ph, phb, ph_tl
!      p_tl, t_tl, u_tl, v_tl, w_tl
!      moist
!      moist_tl
!      mu, psfc
!      mu_tl, psfc_tl
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    IMPLICIT NONE
! control parameter for theta computation/displacemnt
    INTEGER(I_KIND), INTENT(IN) :: th_compute
    integer(i_kind), intent(in) :: istep
! index for qvapor
    INTEGER(I_KIND), INTENT(IN) :: qv_ind, nmoist
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: p, pb, t, u, v, w
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: ph, phb, ph_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: p_tl, t_tl, u_tl, v_tl, w_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme, 1:nmoist), INTENT(INOUT) :: moist
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme, 1:nmoist), INTENT(INOUT) :: moist_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: hgt, mub
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: mu, psfc
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: mu_tl, psfc_tl
    real(r_kind), DIMENSION(kms:kme), INTENT(IN) :: znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
    real(r_kind), INTENT(IN) :: ptop
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    type (fca_gridded_disp), intent(in) :: fcadisp_tl			! displacement field generated by FCA routine
    integer(i_kind), intent(in) :: interp_order
! hydrostatic component for geopotential
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_hyd, ph_nl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_hyd_tl, ph_nl_tl
! work space for 2d original/displaced fields
    real(r_kind), DIMENSION(ims:ime, jms:jme, 2) :: work2d
    real(r_kind), DIMENSION(ims:ime, jms:jme, 2) :: work2d_tl
    INTEGER(I_KIND) :: i, status
    INTEGER(I_KIND) :: result1

#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("displace_wrf_fields_tl")
#endif
! we need the nonhydrostatic component of the geopotential to apply after displacements to get the total PH
! Before doing anything with the displacements, get the hydrostatic component of the geopotential
    CALL CALC_PH_HYD_WRF_TL(moist(:, :, :, qv_ind), moist_tl(:, :, :, &
         qv_ind), p, p_tl, pb, t, t_tl, hgt, mu, mu_tl, mub &
         , c3h,c4h,c3f,c4f, ptop, ph_hyd, ph_hyd_tl)
! save the nonhydrostatic component for later use
    ph_nl_tl = ph_tl - ph_hyd_tl
    ph_nl = ph + phb - ph_hyd
! Adjust fields which are to be directly displaced (momentum and hydrometeor mixing ratios)
    work2d_tl = 0.0_r_kind
    CALL APPLY_VERT_TL(u, u_tl, 0, work2d, work2d_tl, fcadisp, fcadisp_tl, interp_order)
    if (istep .le. 1) return
    CALL APPLY_VERT_TL(v, v_tl, 0, work2d, work2d_tl, fcadisp, fcadisp_tl, interp_order)
    if (istep .le. 2) return
    ! NOT: Only apply displacements to first kte levels, even for staggered variables w, ph_nl
    CALL APPLY_VERT_TL(w, w_tl, 1, work2d, work2d_tl, fcadisp, fcadisp_tl, interp_order)
    if (istep .le. 3) return
    CALL APPLY_VERT_TL(ph_nl, ph_nl_tl, 1, work2d, work2d_tl, fcadisp, fcadisp_tl, interp_order)
    if (istep .le. 4) return
    result1 = SIZE(moist, 4)
    DO i=1,SIZE(moist, 4)
      IF (i .NE. qv_ind) CALL APPLY_VERT_TL(moist(:, :, :, i), moist_tl(:, :, :, i), &
           0, work2d, work2d_tl, fcadisp, fcadisp_tl, interp_order)
    END DO
    if (istep .le. 5) return
!!$         'Completed simple displacements. Now recalculating derived fields_tl'
! Recalculate secondary fields from the newly displaced ones
    CALL ADJ_WRF_DERIVED_TL(moist(:, :, :, qv_ind), moist_tl(:, :, :, &
                      qv_ind), p, p_tl, pb, t, t_tl, ph, ph_tl, phb, &
                      ph_nl, ph_nl_tl, hgt, mub, mu, mu_tl, psfc, &
                      psfc_tl, znu, znw, c1h, c2h, c3h, c4h, c3f, c4f, ptop, &
                      th_compute, fcadisp, fcadisp_tl,istep, interp_order)

#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("displace_wrf_fields_tl")
#endif

END SUBROUTINE DISPLACE_WRF_FIELDS_TL

SUBROUTINE CALC_PH_HYD_WRF_TL(qvapor, qvapor_tl, p, p_tl, pb, t, t_tl&
     , hgt, mu, mu_tl, mub,c3h,c4h,c3f,c4f, ptop, ph_hyd, ph_hyd_tl)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: calc_ph_hyd_wrf_tl
!   prgmmr: Nehrkorn
!
! abstract: compute hydrostatic geopotential height
!
! program history log:
!
!   input argument list: 
!       qvapor, p, pb, t
!       qvapor_tl, p_tl, t_tl
!       hgt, mu, mub
!       mu_tl
!       c3h,c4h,c3f,c4f
!       ptop
!
!   output argument list:
!      ph_hyd, ph_hyd_tl
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    IMPLICIT NONE
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(IN) :: qvapor, p, pb, t
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(IN) :: qvapor_tl, p_tl, t_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: hgt, mu, mub
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: mu_tl
    real(r_kind), DIMENSION(kms:kme), INTENT(IN) :: c3h,c4h,c3f,c4f
    real(r_kind), INTENT(IN) :: ptop
! nonhydrostatic component for geopotential
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(OUT) :: ph_hyd
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(OUT) :: ph_hyd_tl
    INTEGER(I_KIND) :: i
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: rhod
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: rhod_tl
    real(r_kind), dimension(ims:ime,jms:jme) :: pfu,pfd,phm
    real(r_kind), dimension(ims:ime,jms:jme) :: pfu_tl,pfd_tl,phm_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: pwx1
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: pwx1_tl
    real(r_kind) :: pwy1
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: pwr1
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: pwr1_tl
    INTRINSIC SIZE

#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("calc_ph_hyd_wrf_tl")
#endif

! calculate dry air density
    pwx1_tl(:,:,kts:kte) = p_tl(:,:,kts:kte)/p0
    pwx1(:,:,kts:kte) = (p(:,:,kts:kte)+pb(:,:,kts:kte))/p0
    pwy1 = rd/cp
    pwr1_tl(:,:,kts:kte) = pwy1*pwx1(:,:,kts:kte)**(pwy1-1)*pwx1_tl(:,:,kts:kte)
    pwr1(:,:,kts:kte) = pwx1(:,:,kts:kte)**pwy1
    rhod_tl(:,:,kts:kte) = ((p_tl(:,:,kts:kte)*(1-rv/rd*qvapor(:,:,kts:kte))-&
         (p(:,:,kts:kte)+pb(:,:,kts:kte))*rv*qvapor_tl(:,:,kts:kte)/rd)*rd*(t(:,:,kts:kte)+t0)&
       *pwr1(:,:,kts:kte)-(p(:,:,kts:kte)+pb(:,:,kts:kte))*(1-rv/rd*qvapor(:,:,kts:kte))*rd&
       *(t_tl(:,:,kts:kte)*pwr1(:,:,kts:kte)+(t(:,:,kts:kte)+t0)*pwr1_tl(:,:,kts:kte)))/(rd*&
       (t(:,:,kts:kte)+t0)*pwr1(:,:,kts:kte))**2
    rhod(:,:,kts:kte) = (p(:,:,kts:kte)+pb(:,:,kts:kte))*(1-rv/rd*qvapor(:,:,kts:kte))/&
         (rd*(t(:,:,kts:kte)+t0)*pwr1(:,:,kts:kte))
! to start, store the hydrostatic geopotential in the hydrostatic result
    ph_hyd_tl(:, :, 1) = 0.0_r_kind
    ph_hyd(:, :, 1) = grav*hgt
    ph_hyd_tl = 0.0_r_kind
    DO i=kts+1,kte+1
      pfu_tl(:,:) = MU_tl(:,:)*C3F(i)
      pfu(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i)  +C4F(i)
      pfd_tl(:,:) = MU_tl(:,:)*C3F(i-1)
      pfd(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i-1)+C4F(i-1)
      phm_tl(:,:) = MU_tl(:,:)*C3H(i-1)
      phm(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3H(i-1)+C4H(i-1)
      ph_hyd_tl(:,:,i) = ph_hyd_tl(:,:,i-1) &
           - rhod_tl(:,:,i-1)*phm(:,:)*log(pfd(:,:)/pfu(:,:))/rhod(:,:,i-1)**2 &
           + (phm_tl(:,:)/rhod(:,:,i-1))*log(pfd(:,:)/pfu(:,:)) &
           + (phm(:,:)/rhod(:,:,i-1))*(pfd_tl(:,:)/pfd(:,:)-pfu_tl(:,:)/pfu(:,:))
      ph_hyd(:,:,i) = ph_hyd(:,:,i-1) + phm(:,:)*log(pfd(:,:)/pfu(:,:))/rhod(:,:,i-1)
    END DO
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("calc_ph_hyd_wrf_tl")
#endif
END SUBROUTINE CALC_PH_HYD_WRF_TL

SUBROUTINE ADJ_WRF_DERIVED_TL(qvapor, qvapor_tl, p, p_tl, pb, t, t_tl&
    , ph, ph_tl, phb, ph_nl, ph_nl_tl, hgt, mub, mu, mu_tl, psfc, &
    psfc_tl, znu, znw, c1h, c2h, c3h, c4h, c3f, c4f, ptop, th_compute, fcadisp, fcadisp_tl, istep, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: adj_wrf_derived_tl
!   prgmmr: Nehrkorn
!
! abstract: Compute secondary fields from adjusted fields
!           Requires surface pressure and water vapor increments
!
! program history log:
!
!   input argument list: 
!       qvapor, p, pb, t, ph, qvapor_tl, p_tl, t_tl, ph_tl
!       ph_nl, phb, ph_nl_tl
!       hgt, mub
!       mu, psfc, mu_tl, psfc_tl
!       znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
!       ptop
!       fcadisp			! displacement field generated by FCA routine
!       fcadisp_tl			! displacement field generated by FCA routine
!       th_compute				! control parameter for theta computation/displacemnt
!       istep
!       interp_order
!
!   output argument list:
!       qvapor, p, pb, t, ph, qvapor_tl, p_tl, t_tl, ph_tl
!       mu, psfc, mu_tl, psfc_tl
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    IMPLICIT NONE
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: qvapor, p, pb, t
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: ph
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: qvapor_tl, p_tl, t_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: ph_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(IN) :: ph_nl, phb
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(IN) :: ph_nl_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: hgt, mub
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: mu, psfc
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: mu_tl, psfc_tl
    real(r_kind), DIMENSION(kms:kme), INTENT(IN) :: znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
    real(r_kind), INTENT(IN) :: ptop
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    type (fca_gridded_disp), intent(in) :: fcadisp_tl			! displacement field generated by FCA routine
! control parameter for theta computation/displacemnt
    INTEGER(I_KIND), INTENT(IN) :: th_compute
    integer(i_kind), intent(in) :: istep
    integer(i_kind), intent(in) :: interp_order
    INTEGER(I_KIND) :: i, j, k, q_ind, numvars=1
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: tk, ptot, p_inc, q_inc
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: tk_tl, ptot_tl, p_inc_tl, q_inc_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_temp
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_temp_tl
    real(r_kind), dimension(ims:ime,jms:jme) :: pfu,pfd,phm
    real(r_kind), dimension(ims:ime,jms:jme) :: pfu_tl,pfd_tl,phm_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: sum1, sum2, sum3
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: sum1_tl, sum2_tl, sum3_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, 2) :: work2d
    real(r_kind), DIMENSION(ims:ime, jms:jme, 2) :: work2d_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: tbl, ts, tm, zl, tslv, pslv, ps_inc, mu_inc
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: tbl_tl, ts_tl, tm_tl&
     , zl_tl, tslv_tl, pslv_tl, ps_inc_tl, mu_inc_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: pwx1
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: pwx1_tl
    real(r_kind) :: pwy1
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: pwr1
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: pwr1_tl
    real(r_kind) :: arg1
    real(r_kind) :: arg1_tl
    real(r_kind) :: arg2
    real(r_kind) :: arg2_tl
    real(r_kind) :: arg3
    real(r_kind) :: arg3_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: pwx10
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: pwx10_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: pwr10
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: pwr10_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: arg10
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: arg10_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: result1
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: result1_tl

    real(r_kind), parameter :: fp_zero=0., fp_one=1., fp_two=2., p100mbPa=10000._r_kind
#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("adj_wrf_derived_tl")
#endif
    ptot_tl(:,:,kts:kte) = p_tl(:,:,kts:kte)
    ptot(:,:,kts:kte) = p(:,:,kts:kte) + pb(:,:,kts:kte)
! Use un-displaced temperature (K) for all conversions below
    pwx1_tl(:,:,kts:kte) = ptot_tl(:,:,kts:kte)/p0
    pwx1(:,:,kts:kte) = ptot(:,:,kts:kte)/p0
    pwy1 = rd/cp
    pwr1_tl(:,:,kts:kte) = pwy1*pwx1(:,:,kts:kte)**(pwy1-1)*pwx1_tl(:,:,kts:kte)
    pwr1(:,:,kts:kte) = pwx1(:,:,kts:kte)**pwy1
    tk_tl(:,:,kts:kte) = t_tl(:,:,kts:kte)*pwr1(:,:,kts:kte) + (t(:,:,kts:kte)+t0)*pwr1_tl(:,:,kts:kte)
    tk(:,:,kts:kte) = (t(:,:,kts:kte)+t0)*pwr1(:,:,kts:kte)
    IF (th_compute .EQ. 1) THEN
      CALL DISPLACE_THETA_WRF_TL(t, t_tl, ph, ph_tl, phb, fcadisp, fcadisp_tl, interp_order)
! displace and overwite theta
!!$       call displace_theta_wrf(t,ph,phb,fcadisp)			! displace and overwite theta
      tbl_tl = 0.0_r_kind
      work2d_tl = 0.0_r_kind
    ELSE
!!$       call apply_vert(t,0,work2d,fcadisp)
      work2d_tl = 0.0_r_kind
      CALL APPLY_VERT_TL(t, t_tl, 0, work2d, work2d_tl, fcadisp, fcadisp_tl, interp_order)
      tbl_tl = 0.0_r_kind
    END IF
    if (istep .le. 6) return
! Find the temperature 100 mb AGL
    DO i= ims, ime
      DO j= jms, jme
! first check is top model level is top of PBL -- very unlikely but included for robustness
        IF (ptot(i, j, kte) .EQ. psfc(i, j) - p100mbPa) THEN
          tbl_tl(i, j) = tk_tl(i, j, kte)
          tbl(i, j) = tk(i, j, kte)
        END IF
        DO k= kts, kte-1
          IF (ptot(i, j, k+1) .EQ. psfc(i, j) - p100mbPa) THEN
            tbl_tl(i, j) = tk_tl(i, j, k+1)
            tbl(i, j) = tk(i, j, k+1)
          ELSE IF (ptot(i, j, k) .GT. psfc(i, j) - p100mbPa .AND. ptot(i, j&
               , k+1) .LT. psfc(i, j) - p100mbPa) THEN
            arg1_tl = (ptot_tl(i, j, k)*(psfc(i, j)-p100mbPa)-ptot(i, j, k)&
               *psfc_tl(i, j))/(psfc(i, j)-p100mbPa)**2
            arg1 = ptot(i, j, k)/(psfc(i, j)-p100mbPa)
            arg2_tl = (psfc_tl(i, j)*ptot(i, j, k+1)-(psfc(i, j)-p100mbPa)*&
               ptot_tl(i, j, k+1))/ptot(i, j, k+1)**2
            arg2 = (psfc(i, j)-p100mbPa)/ptot(i, j, k+1)
            arg3_tl = (ptot_tl(i, j, k)*ptot(i, j, k+1)-ptot(i, j, k)*&
               ptot_tl(i, j, k+1))/ptot(i, j, k+1)**2
            arg3 = ptot(i, j, k)/ptot(i, j, k+1)
            tbl_tl(i, j) = ((tk_tl(i, j, k+1)*LOG(arg1)+tk(i, j, k+1)*&
               arg1_tl/arg1+tk_tl(i, j, k)*LOG(arg2)+tk(i, j, k)*arg2_tl/&
               arg2)*LOG(arg3)-(tk(i, j, k+1)*LOG(arg1)+tk(i, j, k)*LOG(&
               arg2))*arg3_tl/arg3)/LOG(arg3)**2
            tbl(i, j) = (tk(i, j, k+1)*LOG(arg1)+tk(i, j, k)*LOG(arg2))/&
               LOG(arg3)
          END IF
        END DO
      END DO
    END DO
!surface temperature from 100 mb AGL
    pwx10_tl = (psfc_tl*(psfc-p100mbPa)-psfc*psfc_tl)/(psfc-p100mbPa)**2
    pwx10 = psfc/(psfc-p100mbPa)
    pwy1 = rd*gamma/grav
    pwr10_tl = pwy1*pwx10**(pwy1-1)*pwx10_tl
    pwr10 = pwx10**pwy1
    ts_tl = tbl_tl*pwr10 + tbl*pwr10_tl
    ts = tbl*pwr10
!mean 100mb layer temperature
    tm_tl = (tbl_tl+ts_tl)/fp_two
    tm = (tbl+ts)/fp_two
!Height AGL for 100mb AGL
    zl_tl = -(rd*((psfc_tl*psfc-(psfc-p100mbPa)*psfc_tl)*tm/(psfc*(psfc-&
       p100mbPa))+LOG((psfc-p100mbPa)/psfc)*tm_tl)/grav)
    zl = hgt - rd/grav*LOG((psfc-p100mbPa)/psfc)*tm
! Temperature at sea level using lapse rate gamma (6.5K/km)
    tslv_tl = tbl_tl + gamma*zl_tl
    tslv = tbl + gamma*zl
!sea-level pressure
    arg10_tl(:, :) = -(grav*hgt*rd*(ts_tl+tslv_tl)/fp_two/(rd*(ts+tslv)/fp_two)&
       **2)
    arg10(:, :) = grav*hgt/(rd*(ts+tslv)/fp_two)
    pslv_tl = psfc_tl*EXP(arg10(:, :)) + psfc*arg10_tl(:, :)*EXP(arg10(:&
       , :))
    pslv = psfc*EXP(arg10(:, :))
! Now perform displacement of sea level pressure
    CALL APPLY_DISP_2D_TL(pslv, work2d(:, :, 1), fcadisp, &
         work2d_tl(:, :, 1), fcadisp_tl, interp_order)
! compute the new Psfc
    arg10_tl(:, :) = -(grav*hgt*rd*(ts_tl+tslv_tl)/fp_two/(rd*(ts+tslv)/fp_two)&
       **2)
    arg10(:, :) = grav*hgt/(rd*(ts+tslv)/fp_two)
    work2d_tl(:, :, 2) = (work2d_tl(:, :, 1)*EXP(arg10(:, :))-work2d(:, &
       :, 1)*arg10_tl(:, :)*EXP(arg10(:, :)))/EXP(arg10(:, :))**2
    work2d(:, :, 2) = work2d(:, :, 1)/EXP(arg10(:, :))
! get the surface pressure increment
    ps_inc_tl = work2d_tl(:, :, 2) - psfc_tl
    ps_inc = work2d(:, :, 2) - psfc
! Store the new Psfc
    psfc_tl = work2d_tl(:, :, 2)
    psfc = work2d(:, :, 2)
    if (istep .le. 7) return
    q_inc_tl = 0.0_r_kind
    DO k = kts, kte
! displace RH
      work2d_tl(:, :, 1) = SH2RH_TL(qvapor(:, :, k), qvapor_tl(:, :, k)&
         , tk(:, :, k), tk_tl(:, :, k), ptot(:, :, k), ptot_tl(:, :, k), &
         work2d(:, :, 1))
      CALL APPLY_DISP_2D_TL(work2d(:, :, 1), q_inc(:, :, k), fcadisp, &
           q_inc_tl(:, :, k), fcadisp_tl, interp_order)
! calculate and store increments using q from the adjusted RH
      result1_tl = RH2SH_TL(q_inc(:, :, k), q_inc_tl(:, :, k), tk(:, :, &
         k), tk_tl(:, :, k), ptot(:, :, k), ptot_tl(:, :, k), result1)
      q_inc_tl(:, :, k) = result1_tl - qvapor_tl(:, :, k)
      q_inc(:, :, k) = result1 - qvapor(:, :, k)
    END DO
! apply qvapor increments
    qvapor_tl(:, :, :) = qvapor_tl(:, :, :) + q_inc_tl
    qvapor(:, :, :) = qvapor(:, :, :) + q_inc
    if (istep .le. 8) return
    sum1 = fp_zero
! Find dry mass increments
    sum2 = fp_zero
    sum3 = fp_zero
    sum1_tl = fp_zero
    sum2_tl = fp_zero
    sum3_tl = fp_zero
    DO i= kte, kts, -1
       pfu_tl(:,:) = MU_tl(:,:)*C3F(i+1)
       pfu(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i+1)+C4F(i+1)
       pfd_tl(:,:) = MU_tl(:,:)*C3F(i)
       pfd(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i)  +C4F(i)
       phm_tl(:,:) = MU_tl(:,:)*C3H(i)
       phm(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3H(i)  +C4H(i)
       sum1_tl = sum1_tl &
            + q_inc_tl(:,:,i)*phm(:,:)*log(pfd(:,:)/pfu(:,:)) &
            + q_inc(:,:,i)*phm_tl(:,:)*log(pfd(:,:)/pfu(:,:)) &
            + q_inc(:,:,i)*phm(:,:)*(pfd_tl(:,:)/pfd(:,:)-pfu_tl(:,:)/pfu(:,:))
       sum1 = sum1 + q_inc(:,:,i)*phm(:,:)*log(pfd(:,:)/pfu(:,:))
       sum2_tl = sum2_tl &
            + qvapor_tl(:,:,i)*phm(:,:)*log(pfd(:,:)/pfu(:,:)) &
            + (1+qvapor(:,:,i))*phm_tl(:,:)*log(pfd(:,:)/pfu(:,:)) &
            + (1+qvapor(:,:,i))*phm(:,:)*(pfd_tl(:,:)/pfd(:,:)-pfu_tl(:,:)/pfu(:,:))
       sum2 = sum2 + (1+qvapor(:,:,i))*phm(:,:)*log(pfd(:,:)/pfu(:,:))
       sum3_tl = sum3_tl &
            + phm_tl(:,:)*log(pfd(:,:)/pfu(:,:)) &
            + phm(:,:)*(pfd_tl(:,:)/pfd(:,:)-pfu_tl(:,:)/pfu(:,:))            
       sum3 = sum3 + phm(:,:)*log(pfd(:,:)/pfu(:,:))
    END DO
    mu_inc_tl = sum3_tl*(ps_inc-sum1)/sum2 &
         + sum3*(ps_inc_tl - sum1_tl)/sum2 &
         - sum2_tl*sum3*(ps_inc - sum1)/sum2**2
    mu_inc = sum3*(ps_inc-sum1)/sum2
    
    ! Update the dry air mass
    mu_tl = mu_tl + mu_inc_tl
    mu = mu + mu_inc
    if (istep .le. 9) return
    p_inc_tl = 0.0_r_kind
! Update the pressure field
    DO i = kte, kts, -1
       p_inc_tl(:,:,i) = (znw(i)-znw(i+1))* &
            (mu_inc_tl*c1h(i)*(fp_one+qvapor(:,:,i)) &
             + mu_inc*c1h(i)*qvapor_tl(:,:,i) &
             + mu_tl*c1h(i)*q_inc(:,:,i) &
             + (c1h(i)*(mu+mub)+c2h(i))*q_inc_tl(:,:,i))
       p_inc(:,:,i) = (mu_inc*c1h(i)*(fp_one+qvapor(:,:,i)) + &
            (c1h(i)*(mu+mub)+c2h(i))*q_inc(:,:,i))*(znw(i)-znw(i+1))
      IF (i .LT. kte) THEN
        p_inc_tl(:, :, i) = p_inc_tl(:, :, i) + p_inc_tl(:, :, i+1)
        p_inc(:, :, i) = p_inc(:, :, i) + p_inc(:, :, i+1)
      END IF
    END DO
    p_tl = p_tl + p_inc_tl
    p = p + p_inc
    if (istep .le. 10) return
! update the geopotential
    CALL CALC_PH_HYD_WRF_TL(qvapor, qvapor_tl, p, p_tl, pb, t, t_tl, hgt&
         , mu, mu_tl, mub, c3h,c4h,c3f,c4f, ptop, ph_temp, ph_temp_tl)
! get the hydrostatic geopotential
! add the saved nonhydrostatic component
    ph_temp_tl = ph_temp_tl + ph_nl_tl
    ph_temp = ph_temp + ph_nl
! remove the base component
    ph_tl = ph_temp_tl
    ph = ph_temp - phb
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("adj_wrf_derived_tl")
#endif
END SUBROUTINE ADJ_WRF_DERIVED_TL

SUBROUTINE DISPLACE_THETA_WRF_TL(t, t_tl, ph, ph_tl, phb, fcadisp, fcadisp_tl, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: displace_theta_wrf_tl
!   prgmmr: Nehrkorn
!
! abstract: Displace potential temperature field while accounting for the environmental lapse rate
!
! program history log:
!
!   input argument list: 
!       t, t_tl
!       ph, phb, ph_tl
!       fcadisp			! displacement field generated by FCA routine
!       fcadisp_tl		! displacement field generated by FCA routine
!       interp_order
!
!   output argument list:
!       t, t_tl
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    IMPLICIT NONE
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: t
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: t_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(IN) :: ph, phb
    real(r_kind), DIMENSION(:, :, :), INTENT(IN) :: ph_tl
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    type (fca_gridded_disp), intent(in) :: fcadisp_tl			! displacement field generated by FCA routine
    integer(i_kind), intent(in) :: interp_order
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_tot
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: &
     ph_tot_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: tknew, znew, zlvl
    real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: tknew_tl, znew_tl, zlvl_tl
    INTEGER(I_KIND) :: k
    INTRINSIC SIZE
#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("displace_theta_wrf_tl")
#endif
    ph_tot_tl = ph_tl
    ph_tot = ph + phb
    zlvl_tl = 0.0_r_kind
    znew_tl = 0.0_r_kind
! find vertical displacement of theta mass level   
    DO k= kts, kte
! get vertical displacement distance
      zlvl_tl(:, :, k) = (ph_tot_tl(:, :, k)+ph_tot_tl(:, :, k+1))/2/&
         grav
      zlvl(:, :, k) = (ph_tot(:, :, k)+ph_tot(:, :, k+1))/2/grav
      CALL APPLY_DISP_2D_TL(zlvl(:, :, k), znew(:, :, k), fcadisp, &
           znew_tl(:, :, k), fcadisp_tl, interp_order)
    END DO
! displace theta
    CALL APPLY_DISP_THETA_TL(fcadisp, fcadisp_tl, t, t_tl, zlvl, zlvl_tl, znew, znew_tl, &
                        tknew, tknew_tl, interp_order)
    t_tl = tknew_tl
    t = tknew
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("displace_theta_wrf_tl")
#endif
END SUBROUTINE DISPLACE_THETA_WRF_TL

SUBROUTINE APPLY_DISP_THETA_TL(fcadisp, fcadisp_tl, &
       tk, tk_tl, zlvl, zlvl_tl, znew, znew_tl, tknew, tknew_tl, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: apply_disp_theta_tl
!   prgmmr: Nehrkorn
!
! abstract: apply displacements to the 3d theta field
!
! program history log:
!
!   input argument list: 
!       fcadisp			! displacement field generated by FCA routine
!       fcadisp_tl		! displacement field generated by FCA routine
!       znew, TK, zlvl          ! displaced (new) height values, original field, original height values
!       znew_tl, TK_tl, zlvl_tl ! displaced (new) height values, original field, original height values
!       interp_order
!
!   output argument list:
!       tknew, tknew_tl         ! displaced theta
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    IMPLICIT NONE
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    type (fca_gridded_disp), intent(in) :: fcadisp_tl			! displacement field generated by FCA routine
    real(r_kind), DIMENSION(ims:ime,jms:jme,kms:kme), INTENT(IN) :: znew, tk, zlvl
    real(r_kind), DIMENSION(ims:ime,jms:jme,kms:kme), INTENT(IN) :: znew_tl, tk_tl, zlvl_tl
    real(r_kind), DIMENSION(ims:ime,jms:jme,kms:kme), INTENT(OUT) :: tknew
    real(r_kind), DIMENSION(ims:ime,jms:jme,kms:kme), INTENT(OUT) :: tknew_tl
    integer(i_kind), intent(in) :: interp_order
    INTEGER(I_KIND) :: i, j, k, l
    INTEGER(I_KIND) :: ibot, itop
! theta above and below level for interpolation
    real(r_kind), DIMENSION(SIZE(tk, 1), SIZE(tk, 2), 2) :: t_bot_top
    real(r_kind), DIMENSION(SIZE(tk, 1), SIZE(tk, 2), 2) :: t_bot_top_tl

#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("apply_disp_theta_tl")
#endif
    tknew = -999_r_kind
! initialize TKnew as missing
    ibot = 1
! Compute new theta at bottom level
    t_bot_top_tl = 0.0_r_kind
    CALL APPLY_DISP_2D_TL(tk(:, :, 1), t_bot_top(:, :, ibot), fcadisp, &
         t_bot_top_tl(:, :, ibot), fcadisp_tl, interp_order)
    itop = 1
    tknew_tl = 0.0_r_kind
    DO l=kts,kte-1
! switch top and bottom index
      ibot = itop
      IF (ibot .EQ. 1) THEN
        itop = 2
      ELSE
        itop = 1
      END IF
! Compute new theta at top level
      CALL APPLY_DISP_2D_TL(tk(:, :, l+1), t_bot_top(:, :, itop), fcadisp, &
           t_bot_top_tl(:, :, itop), fcadisp_tl, interp_order)
      DO k=kts,kte
        WHERE (zlvl(:, :, k) .GT. znew(:, :, l) .AND. zlvl(:, :, k) .LE.&
             znew(:, :, l+1)) 
          tknew_tl(:, :, k) = &
               t_bot_top_tl(:, :, itop)*(zlvl(:, :, k)-znew(:, :, l))/&
                (znew(:, :, l+1)-znew(:, :, l)) &
               + zlvl_tl(:, :, k)*(t_bot_top(:, :, itop)-t_bot_top(:, :, ibot))/&
                (znew(:, :, l+1)-znew(:, :, l)) &
               - znew_tl(:, :, l)*((t_bot_top(:, :, itop)-t_bot_top(:, :, ibot))/&
                (znew(:, :, l+1)-znew(:, :, l)) &
                - (t_bot_top(:, :, itop)-t_bot_top(:, :, ibot))*(zlvl(:, :, k)-znew(:, :, l))/&
                (znew(:, :, l+1)-znew(:, :, l))**2) &
               - znew_tl(:, :, l+1)*(t_bot_top(:, :, itop)-t_bot_top(:, :, ibot))*(zlvl(:, :, k)-znew(:, :, l))/&
                (znew(:, :, l+1)-znew(:, :, l))**2 &
               + t_bot_top_tl(:, :, ibot)*(1-(zlvl(:, :, k)-znew(:, :, l)) / &
               (znew(:, :, l+1)-znew(:, :, l)))

          tknew(:, :, k) = t_bot_top(:, :, itop)*(zlvl(:, :, k)-znew(:, &
             :, l))/(znew(:, :, l+1)-znew(:, :, l)) + t_bot_top(:, :, &
             ibot)*(1-(zlvl(:, :, k)-znew(:, :, l))/(znew(:, :, l+1)-znew&
             (:, :, l)))
        END WHERE
        IF (l .EQ. 1) THEN
          WHERE (zlvl(:, :, k) .LE. znew(:, :, l)) 
            tknew_tl(:, :, k) = t_bot_top_tl(:, :, ibot)
            tknew(:, :, k) = t_bot_top(:, :, ibot)
          END WHERE
        ELSE IF (l .EQ. kte - 1) THEN
          WHERE (zlvl(:, :, k) .GE. znew(:, :, l+1)) 
            tknew_tl(:, :, k) = t_bot_top_tl(:, :, itop)
            tknew(:, :, k) = t_bot_top(:, :, itop)
          END WHERE
        END IF
      END DO
    END DO
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("apply_disp_theta_tl")
#endif
END SUBROUTINE APPLY_DISP_THETA_TL

 FUNCTION SH2RH_TL(hum, hum_tl, t, t_tl, parr, parr_tl, sh2rh)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: sh2rh_tl
!   prgmmr: Nehrkorn
!
! abstract: Convert mixing ratio (kg/kg) to relative humidity (%)
!           ! Formulas and constants from WRFV3.2.1 (module_initialize_real.F, Registry.EM)
!
! program history log:
!
!   input argument list: 
!    hum, hum_tl - mixing ratio (kg/kg)
!    t, t_tl - temperature (K)
!    parr,parr_tl - pressure (Pa)
!    sh2rh - workspace
!
!   output argument list:
!    sh2rh - relative humidity
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    IMPLICIT NONE
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: hum, t, parr
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: hum_tl, t_tl, parr_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: sh2rh
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: sh2rh_tl
    INTEGER(I_KIND) :: i, j
    real(r_kind) :: r, e, esat, p
    real(r_kind) :: r_tl, e_tl, esat_tl, p_tl
    real(r_kind) :: rdorv, ew, t1
    real(r_kind) :: ew_tl, t1_tl
! From module_intialize_real.F:
    real(r_kind), PARAMETER :: t_ref=0.0_r_kind
    real(r_kind), PARAMETER :: mw_air=28.966_r_kind
    real(r_kind), PARAMETER :: mw_vap=18.0152_r_kind
    real(r_kind), PARAMETER :: a0=6.107799961_r_kind
    real(r_kind), PARAMETER :: a1=4.436518521e-01_r_kind
    real(r_kind), PARAMETER :: a2=1.428945805e-02_r_kind
    real(r_kind), PARAMETER :: a3=2.650648471e-04_r_kind
    real(r_kind), PARAMETER :: a4=3.031240396e-06_r_kind
    real(r_kind), PARAMETER :: a5=2.034080948e-08_r_kind
    real(r_kind), PARAMETER :: a6=6.136820929e-11_r_kind
    real(r_kind), PARAMETER :: es0=6.1121_r_kind
    real(r_kind), PARAMETER :: c1=9.09718_r_kind
    real(r_kind), PARAMETER :: c2=3.56654_r_kind
    real(r_kind), PARAMETER :: c3=0.876793_r_kind
    real(r_kind), PARAMETER :: eis=6.1071_r_kind
    real(r_kind) :: rhs
    real(r_kind) :: rhs_tl
    real(r_kind), PARAMETER :: tf=273.16_r_kind
    real(r_kind),         parameter     :: const_47 = -47._r_kind
    real(r_kind),         parameter     :: const_17 = 17.67_r_kind
    real(r_kind),         parameter     :: const_10 = 10._r_kind
    real(r_kind),         parameter     :: const_100 = 100._r_kind
    real(r_kind),         parameter     :: const_243 = 243.5_r_kind
    real(r_kind) :: tk
    real(r_kind) :: tk_tl
    real(r_kind) :: arg1
    real(r_kind) :: arg1_tl
    INTRINSIC EXP
    INTRINSIC SIZE
    INTRINSIC LOG10
    rdorv = mw_vap/mw_air
    sh2rh_tl = 0.0_r_kind
    DO j= jms, jme
      DO i= ims, ime
        p_tl = parr_tl(i, j)
        p = parr(i, j)
        r_tl = hum_tl(i, j)
        r = hum(i, j)
        e_tl = ((p_tl*r+p*r_tl)*(rdorv+r)-p*r*r_tl)/(rdorv+r)**2
        e = p*r/(rdorv+r)
! real formulas wrt liquid/ice:
        t1_tl = t_tl(i, j)
        t1 = t(i, j) - tf
        IF (t1 .GE. t_ref .AND. t1 .GE. const_47) THEN
! liq phase eslo
          ew_tl = t1_tl*(a1+t1*(a2+t1*(a3+t1*(a4+t1*(a5+t1*a6))))) + t1*&
             (t1_tl*(a2+t1*(a3+t1*(a4+t1*(a5+t1*a6))))+t1*(t1_tl*(a3+t1*(&
             a4+t1*(a5+t1*a6)))+t1*(t1_tl*(a4+t1*(a5+t1*a6))+t1*(t1_tl*(&
             a5+t1*a6)+t1*a6*t1_tl))))
          ew = a0 + t1*(a1+t1*(a2+t1*(a3+t1*(a4+t1*(a5+t1*a6)))))
        ELSE IF (t1 .GE. t_ref .AND. t1 .LT. const_47) THEN
!liq phas poor es
          arg1_tl = (const_17*t1_tl*(t1+243.5_r_kind)-const_17*t1*t1_tl)/(t1+243.5_r_kind)**&
             2
          arg1 = const_17*t1/(t1+243.5_r_kind)
          ew_tl = es0*arg1_tl*EXP(arg1)
          ew = es0*EXP(arg1)
        ELSE
          tk_tl = t_tl(i, j)
          tk = t(i, j)
          rhs_tl = c1*tf*tk_tl/tk**2 + c2*tk_tl/(tk*LOG(const_10)) - c3*&
             tk_tl/tf
          rhs = -(c1*(tf/tk-1.)) - c2*LOG10(tf/tk) + c3*(1.-tk/tf) + &
             LOG10(eis)
          ew_tl = const_10**rhs*LOG(const_10)*rhs_tl
          ew = const_10**rhs
        END IF
! factor of 100. to convert from mb (hPa) to Pa:
        esat_tl = const_100*ew_tl
        esat = const_100*ew
        sh2rh_tl(i, j) = (100*e_tl*esat-100*e*esat_tl)/esat**2
        sh2rh(i, j) = const_100*e/esat
        IF (sh2rh(i, j) .GT. const_100) THEN
          sh2rh_tl(i, j) = 0.0_r_kind
          sh2rh(i, j) = const_100
        END IF
      END DO
    END DO
END FUNCTION SH2RH_TL

FUNCTION RH2SH_TL(rh, rh_tl, t, t_tl, parr, parr_tl, rh2sh)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: rh2sh_tl
!   prgmmr: Nehrkorn
!
! abstract: Convert  relative humidity (%) to mixing ratio (kg/kg)
!           ! Formulas and constants from WRFV3.2.1 (module_initialize_real.F, Registry.EM)
!
! program history log:
!
!   input argument list: 
!    rh, rh_tl - relative humidity (%)
!    t, t_tl - temperature (K)
!    parr, parr_tl - pressure (Pa)
!    rh2sh - work space
!
!   output argument list:
!    rh2sh - mixing ratio
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    IMPLICIT NONE
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: rh, t, parr
    real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: rh_tl, t_tl, parr_tl
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: rh2sh
    real(r_kind), DIMENSION(ims:ime, jms:jme) :: rh2sh_tl
    INTEGER(I_KIND) :: i, j
    real(r_kind) :: e, esat, p
    real(r_kind) :: e_tl, esat_tl, p_tl
    real(r_kind) :: rdorv, ew, t1
    real(r_kind) :: ew_tl, t1_tl
! From module_intialize_real.F:
    real(r_kind), PARAMETER :: t_ref=0.0_r_kind
    real(r_kind), PARAMETER :: mw_air=28.966_r_kind
    real(r_kind), PARAMETER :: mw_vap=18.0152_r_kind
    real(r_kind), PARAMETER :: a0=6.107799961_r_kind
    real(r_kind), PARAMETER :: a1=4.436518521e-01_r_kind
    real(r_kind), PARAMETER :: a2=1.428945805e-02_r_kind
    real(r_kind), PARAMETER :: a3=2.650648471e-04_r_kind
    real(r_kind), PARAMETER :: a4=3.031240396e-06_r_kind
    real(r_kind), PARAMETER :: a5=2.034080948e-08_r_kind
    real(r_kind), PARAMETER :: a6=6.136820929e-11_r_kind
    real(r_kind), PARAMETER :: es0=6.1121_r_kind
    real(r_kind), PARAMETER :: c1=9.09718_r_kind
    real(r_kind), PARAMETER :: c2=3.56654_r_kind
    real(r_kind), PARAMETER :: c3=0.876793_r_kind
    real(r_kind), PARAMETER :: eis=6.1071_r_kind
    real(r_kind) :: rhs
    real(r_kind) :: rhs_tl
    real(r_kind), PARAMETER :: tf=273.16_r_kind
    real(r_kind),         parameter     :: const_47 = -47._r_kind
    real(r_kind),         parameter     :: const_17 = 17.67_r_kind
    real(r_kind),         parameter     :: const_10 = 10._r_kind
    real(r_kind),         parameter     :: const_100 = 100._r_kind
    real(r_kind),         parameter     :: const_243 = 243.5_r_kind
    real(r_kind) :: tk
    real(r_kind) :: tk_tl
    real(r_kind) :: arg1
    real(r_kind) :: arg1_tl
    INTRINSIC EXP
    INTRINSIC SIZE
    INTRINSIC LOG10
    rdorv = mw_vap/mw_air
    rh2sh_tl = 0.0_r_kind
    DO j= jms, jme
      DO i= ims, ime
! real formulas wrt liquid/ice:
        t1_tl = t_tl(i, j)
        t1 = t(i, j) - tf
        IF (t1 .GE. t_ref .AND. t1 .GE. const_47) THEN
! liq phase eslo
          ew_tl = t1_tl*(a1+t1*(a2+t1*(a3+t1*(a4+t1*(a5+t1*a6))))) + t1*&
             (t1_tl*(a2+t1*(a3+t1*(a4+t1*(a5+t1*a6))))+t1*(t1_tl*(a3+t1*(&
             a4+t1*(a5+t1*a6)))+t1*(t1_tl*(a4+t1*(a5+t1*a6))+t1*(t1_tl*(&
             a5+t1*a6)+t1*a6*t1_tl))))
          ew = a0 + t1*(a1+t1*(a2+t1*(a3+t1*(a4+t1*(a5+t1*a6)))))
        ELSE IF (t1 .GE. t_ref .AND. t1 .LT. const_47) THEN
!liq phas poor es
          arg1_tl = (const_17*t1_tl*(t1+243.5_r_kind)-const_17*t1*t1_tl)/(t1+243.5_r_kind)**&
             2
          arg1 = const_17*t1/(t1+243.5_r_kind)
          ew_tl = es0*arg1_tl*EXP(arg1)
          ew = es0*EXP(arg1)
        ELSE
          tk_tl = t_tl(i, j)
          tk = t(i, j)
          rhs_tl = c1*tf*tk_tl/tk**2 + c2*tk_tl/(tk*LOG(const_10)) - c3*&
             tk_tl/tf
          rhs = -(c1*(tf/tk-1.)) - c2*LOG10(tf/tk) + c3*(1.-tk/tf) + &
             LOG10(eis)
          ew_tl = const_10**rhs*LOG(const_10)*rhs_tl
          ew = const_10**rhs
        END IF
! factor of 100. to convert from mb (hPa) to Pa
        esat_tl = const_100*ew_tl
        esat = const_100*ew
! total pressure
        p_tl = parr_tl(i, j)
        p = parr(i, j)
! vapor pressure ; scale percent RH to decimal
        e_tl = (esat_tl*rh(i, j)+esat*rh_tl(i, j))/const_100
        e = esat*rh(i, j)/const_100
! mixing ratio
        rh2sh_tl(i, j) = (rdorv*e_tl*(p-e)-rdorv*e*(p_tl-e_tl))/(p-e)**2
        rh2sh(i, j) = rdorv*e/(p-e)
      END DO
    END DO
END FUNCTION RH2SH_TL

#ifdef FCA_REF_MOD
end module displace_wrf_tl_m
#endif

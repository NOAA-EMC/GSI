#ifdef FCA_REF_MOD
module displace_wrf_m
!$$$ module documentation block
!           .      .    .                                       .
! module:   displace_wrf_m
!  prgmmr: Nehrkorn
!
! abstract: Horizontally displace WRF model fields, non-linear (NLM) version
!
! program history log:
!
! subroutines included:
!   sub displace_wrf_fields
!   sub calc_ph_hyd_wrf
!   sub adj_wrf_derived
!   sub displace_theta_wrf
!   sub apply_disp_theta
!
! functions included:
!   sh2rh
!   rh2sh
!
! variable definition:
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
  use fp_types_m, only: fp
  use core_disp_types_m, only: fca_gridded_disp, ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte
  use core_disp_func_m, only: apply_disp_2d, apply_vert
  implicit none
  private
  public :: displace_wrf_fields
  ! NOTE: The following only needed by displace_wrf_ad_m:
  public :: calc_ph_hyd_wrf, adj_wrf_derived, displace_theta_wrf, apply_disp_theta, sh2rh, rh2sh
  ! Physical constants specific to WRF physics routines (as in WRFV3/share/module_model_constants.F):
  real(fp), parameter, public :: t0 = 300.0  !Basic state potential temperature (K)
  real(fp), parameter, public :: p0 = 1E5  !basic state dry surface pressure
  real(fp), parameter, public :: gas_constant = 287.0     !dry air gas constant
  real(fp), parameter, public :: gas_constant_v = 461.6      !water vapor gas constant
  real(fp), parameter, public :: gravity = 9.81
  ! Copy to variable names used here
  real(fp), parameter, public :: grav=gravity !dry air gas constant 
  real(fp), parameter, public :: Rd=gas_constant !dry air gas constant 
  real(fp), parameter, public :: Rv=gas_constant_v !dry air gas constant 
  real(fp), parameter, public :: cp = 7.0*Rd/2.0 !dry air heat capacity at constant pressure
  real(fp), parameter, public :: kappa = Rd / cp !exponent used in computation of theta
  real(fp), parameter, public :: base_pres = p0 !equal to p0
  real(fp), parameter, public :: gamma=0.0065    !lapse rate used for SLP reduction

contains
#else
#define TRACE_USE
#endif

subroutine displace_wrf_fields(th_compute, istep, &
       qv_ind, moist, nmoist, p, pb, t, ph, phb, u, v, w, hgt, mub, mu, psfc, znu, znw, &
       c1h, c2h, c3h, c4h, c3f, c4f, ptop, fcadisp, &
       needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: displace_wrf_fields
!   prgmmr: Nehrkorn
!
! abstract: Horizontally displace WRF model fields
!
! program history log:
!
!   input argument list: 
!      th_compute				! control parameter for theta computation/displacemnt
!      istep				! control parameter for theta computation/displacemnt
!      qv_ind				! index for qvapor
!      nmoist ! number of moisture fields
!      p, pb, t, u, v, w
!      ph, phb
!      moist
!      hgt, mub
!      mu, psfc
!      znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
!      ptop
!      fcadisp			! displacement field generated by FCA routine
!      num_glob_needed, needed_ij_in, needed_ij_out, index_in
!      needed_wgts_out
!      interp_order
!
!   output argument list:
!      p, pb, t, u, v, w
!      ph, phb
!      moist
!      mu, psfc
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block

    implicit none

    integer, intent(in) :: th_compute				! control parameter for theta computation/displacemnt
    integer, intent(in) :: istep				! control parameter for theta computation/displacemnt
    integer, intent(in) :: qv_ind				! index for qvapor
    integer, intent(in) :: nmoist ! number of moisture fields
    real(fp), intent(INOUT), dimension(ims:ime,jms:jme,kms:kme) :: p, pb, t, u, v, w
    real(fp), intent(inout), dimension(ims:ime,jms:jme,kms:kme) ::  ph, phb
    real(fp), intent(INOUT), dimension(ims:ime,jms:jme,kms:kme,1:nmoist) :: moist
    real(fp), intent(IN), dimension(ims:ime,jms:jme) :: hgt, mub
    real(fp), intent(INOUT), dimension(ims:ime,jms:jme) :: mu, psfc
    real(fp), intent(IN), dimension(kms:kme) :: znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
    real(fp), intent(IN) :: ptop
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    integer, intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
    real(fp), intent(in) :: needed_wgts_out(:,:)
    integer, intent(in) :: interp_order

    real(fp), dimension(ims:ime,jms:jme,kms:kme) :: ph_hyd, ph_nl	! hydrostatic component for geopotential
    real(fp), dimension(ims:ime,jms:jme,2) :: work2d		! work space for 2d original/displaced fields
    integer :: i, status
    
#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("displace_wrf_fields")
#endif
    ! we need the nonhydrostatic component of the geopotential to apply after displacements to get the total PH
    ! Before doing anything with the displacements, get the hydrostatic component of the geopotential
    call calc_ph_hyd_wrf(moist(:,:,:,qv_ind),p,pb,t,hgt,mu,mub,c3h,c4h,c3f,c4f,ptop,ph_hyd)
    ph_nl = (ph+phb) - ph_hyd ! save the nonhydrostatic component for later use
    
    ! Adjust fields which are to be directly displaced (momentum and hydrometeor mixing ratios)
    call apply_vert(u, 0, work2d, fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    if (istep .le. 1) return
    call apply_vert(v, 0, work2d, fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    if (istep .le. 2) return
    ! NOT: Only apply displacements to first kte levels, even for staggered variables w, ph_nl
    call apply_vert(w, 1, work2d, fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    if (istep .le. 3) return
    call apply_vert(ph_nl, 1, work2d, fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    if (istep .le. 4) return
    do i = 1, size(moist,4)
       if(i .ne. qv_ind) call apply_vert(moist(:,:,:,i), 0, work2d, fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    end do
    if (istep .le. 5) return

    ! Recalculate secondary fields from the newly displaced ones
    call adj_wrf_derived(moist(:,:,:,qv_ind), p, pb, t, ph, phb, ph_nl, &
         hgt, mub, mu, psfc, znu, znw, c1h, c2h, c3h, c4h, c3f, c4f, ptop, th_compute, fcadisp,istep,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)

#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("displace_wrf_fields")
#endif

end subroutine displace_wrf_fields

subroutine calc_ph_hyd_wrf(qvapor,p,pb,t,hgt,mu,mub,c3h,c4h,c3f,c4f,ptop,ph_hyd)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: calc_ph_hyd_wrf
!   prgmmr: Nehrkorn
!
! abstract: compute hydrostatic geopotential height
!
! program history log:
!
!   input argument list: 
!       qvapor, p, pb, t
!       hgt, mu, mub
!       c3h,c4h,c3f,c4f
!       ptop
!
!   output argument list:
!      ph_hyd
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    real(fp), intent(IN), dimension(ims:ime,jms:jme,kms:kme) :: qvapor, p, pb, t
    real(fp), intent(IN), dimension(ims:ime,jms:jme) :: hgt, mu, mub
    real(fp), intent(IN), dimension(kms:kme) :: c3h,c4h,c3f,c4f
    real(fp), intent(IN) :: ptop
    real(fp), dimension(ims:ime,jms:jme,kms:kme), intent(out) :: ph_hyd		! nonhydrostatic component for geopotential

    integer :: i
    real(fp), dimension(ims:ime,jms:jme,kms:kme) :: rhod
    real(fp), dimension(ims:ime,jms:jme) :: pfu,pfd,phm
    
#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("calc_ph_hyd_wrf")
#endif
    rhod(:,:,kts:kte) = (p(:,:,kts:kte)+pb(:,:,kts:kte))*(1-Rv/Rd*qvapor(:,:,kts:kte)) &
         / (Rd*(t(:,:,kts:kte)+t0)*((p(:,:,kts:kte)+pb(:,:,kts:kte))/p0)**(Rd/cp)) ! calculate dry air density
    ! get eta interface values and d(eta)
    
    ! to start, store the hydrostatic geopotential in the hydrostatic result
    ph_hyd(:,:,kts) = grav*HGT
    do i = kts+1, kte+1
!!$       ph_hyd(:,:,i) = ph_hyd(:,:,i-1)+(mu+mub)/rhod(:,:,i-1)*dEta(i-1) ! replace by formula for hybopt:
      pfu(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i)  +C4F(i)
      pfd(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i-1)+C4F(i-1)
      phm(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3H(i-1)+C4H(i-1)
      ph_hyd(:,:,i) = ph_hyd(:,:,i-1) + phm(:,:)*log(pfd(:,:)/pfu(:,:))/rhod(:,:,i-1)
    end do
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("calc_ph_hyd_wrf")
#endif

end subroutine calc_ph_hyd_wrf

subroutine adj_wrf_derived(qvapor, p, pb, t, ph, phb, ph_nl, hgt, mub, mu, psfc, &
     znu, znw, c1h, c2h, c3h, c4h, c3f, c4f, ptop, th_compute,fcadisp,istep, &
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: adj_wrf_derived
!   prgmmr: Nehrkorn
!
! abstract: Compute secondary fields from adjusted fields
!           Requires surface pressure and water vapor increments
!
! program history log:
!
!   input argument list: 
!       qvapor, p, pb, t, ph
!       ph_nl, phb
!       hgt, mub
!       mu, psfc
!       znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
!       ptop
!       fcadisp			! displacement field generated by FCA routine
!       th_compute				! control parameter for theta computation/displacemnt
!       istep
!       num_glob_needed, needed_ij_in, needed_ij_out, index_in
!       needed_wgts_out
!       interp_order
!
!   output argument list:
!       qvapor, p, pb, t, ph
!       mu, psfc
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    
    implicit none
    real(fp), intent(INOUT), dimension(ims:ime, jms:jme, kms:kme) :: qvapor, p, pb, t, ph
    real(fp), intent(IN), dimension(ims:ime, jms:jme, kms:kme) :: ph_nl, phb
    real(fp), intent(IN), dimension(ims:ime, jms:jme) :: hgt, mub
    real(fp), intent(INOUT), dimension(ims:ime, jms:jme) :: mu, psfc
    real(fp), intent(IN), dimension(kms:kme) :: znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
    real(fp), intent(IN) :: ptop

    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    integer, intent(in) :: th_compute				! control parameter for theta computation/displacemnt
    integer, intent(in) :: istep
    integer, intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
    real(fp), intent(in) :: needed_wgts_out(:,:)
    integer, intent(in) :: interp_order
    integer :: i, j, k, q_ind, numvars=1
    real(fp), dimension(ims:ime, jms:jme, kms:kme) :: TK, Ptot, p_inc, q_inc
    real(fp), dimension(ims:ime, jms:jme, kms:kme) :: ph_temp
    real(fp), dimension(ims:ime,jms:jme) :: pfu,pfd,phm
    real(fp), dimension(ims:ime, jms:jme) :: sum1, sum2, sum3
    real(fp), dimension(ims:ime, jms:jme,2) :: work2d
    real(fp), dimension(ims:ime, jms:jme) :: Tbl, Ts, Tm, Zl, Tslv, Pslv, ps_inc, mu_inc

    real(fp), parameter :: fp_zero=0., fp_one=1., fp_two=2., p100mbPa=10000.
    
#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("adj_wrf_derived")
#endif
    Ptot(:,:,kts:kte) = (p(:,:,kts:kte)+pb(:,:,kts:kte))
    TK(:,:,kts:kte) = (T(:,:,kts:kte)+t0)*(Ptot(:,:,kts:kte)/p0)**(Rd/Cp)	! Use un-displaced temperature (K) for all conversions below
    if(th_compute == 1) then 			! displace and overwite theta
       call displace_theta_wrf(t,ph,phb,fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    else
       ! alternatively just stupidly displace the temperature along model surfaces (not recommended)
       call apply_vert(t,0,work2d,fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    end if
    if (istep .le. 6) return
    ! Find the temperature 100 mb AGL
    do i = ims, ime
       do j = jms, jme
          ! first check if top model level is top of PBL -- very unlikely but included for robustness
          if(Ptot(i,j,kte) == (Psfc(i,j)-p100mbPa)) Tbl(i,j) = TK(i,j,kte)
          do k = kts, kte-1 ! make sure that a 3D field was last loaded (not PSFC)
             if(Ptot(i,j,k+1) == (Psfc(i,j)-p100mbPa)) then
                Tbl(i,j) = TK(i,j,k+1)
             elseif( (Ptot(i,j,k) > (Psfc(i,j)-p100mbPa)) .and. (Ptot(i,j,k+1) < (Psfc(i,j)-p100mbPa)) ) then
                Tbl(i,j) = ( TK(i,j,k+1)*log(Ptot(i,j,k)/(Psfc(i,j)-p100mbPa)) + &
                     TK(i,j,k)*log((Psfc(i,j)-p100mbPa)/Ptot(i,j,k+1)) ) / log(Ptot(i,j,k)/Ptot(i,j,k+1))
             end if
          end do
       end do
    end do
    
    Ts = Tbl*(Psfc/(Psfc-p100mbPa))**(Rd*gamma/grav) !surface temperature from 100 mb AGL
    Tm = (Tbl+Ts)/fp_two                                  !mean 100mb layer temperature
    Zl = HGT - Rd/grav*log((Psfc-p100mbPa)/Psfc)*Tm !Height AGL for 100mb AGL
    Tslv = Tbl + gamma*Zl ! Temperature at sea level using lapse rate gamma (6.5K/km)
    Pslv = Psfc*exp(grav*HGT/(Rd*(Ts+Tslv)/fp_two)) !sea-level pressure
    ! Now perform displacement of sea level pressure
    call apply_disp_2d(Pslv,work2d(:,:,1),fcadisp,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    work2d(:,:,2) = work2d(:,:,1)/exp(grav*HGT/(Rd*(Ts+Tslv)/fp_two))	! compute the new Psfc
    ps_inc = work2d(:,:,2) - Psfc			! get the surface pressure increment
    Psfc = work2d(:,:,2)                            ! Store the new Psfc
    if (istep .le. 7) return
    
    do k = kts, kte
       work2d(:,:,1) = sh2rh(qvapor(:,:,k),TK(:,:,k),Ptot(:,:,k))
       ! displace RH
       call apply_disp_2d(work2d(:,:,1),q_inc(:,:,k),fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
       ! q_inc should now contain the displace relative humidity (bg in work2d)
       ! calculate q from the adjusted RH
       q_inc(:,:,k) = rh2sh(q_inc(:,:,k),TK(:,:,k),Ptot(:,:,k))
       ! convert to q increments
       q_inc(:,:,k) = q_inc(:,:,k) - qvapor(:,:,k)
    end do
    qvapor(:,:,:) = qvapor(:,:,:) + q_inc ! apply qvapor increments
    if (istep .le. 8) return
    
    ! Below we use the updated qvapor field
    ! Find dry mass increments
    sum1 = fp_zero ; sum2 = fp_zero ; sum3 = fp_zero
    do i = kte, kts, -1 ! don't use Nz as it is clobbered!
       pfu(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i+1)+C4F(i+1)
       pfd(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i)  +C4F(i)
       phm(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3H(i)  +C4H(i)
!!$       sum1 = sum1 + q_inc(:,:,i)*dEta(i) ! replace by: mut*sum1=
       sum1 = sum1 + q_inc(:,:,i)*phm(:,:)*log(pfd(:,:)/pfu(:,:))
!!$       sum2 = sum2 + (1+qvapor(:,:,i))*dEta(i)! replace by
       sum2 = sum2 + (fp_one+qvapor(:,:,i))*phm(:,:)*log(pfd(:,:)/pfu(:,:))
       sum3 = sum3 + phm(:,:)*log(pfd(:,:)/pfu(:,:))
    end do
    mu_inc = sum3*(ps_inc-sum1)/sum2
    mu = mu + mu_inc	! Update the dry air mass
    if (istep .le. 9) return

    ! Update the pressure field: downward integration of delta(dp/deta)
    do i = kte, kts, -1
! old: dp/deta=(1+qvapor)*mut
!!$       p_inc(:,:,i) = (mu_inc*(1+qvapor(:,:,i))+(mu+mub)*q_inc(:,:,i))*dEta(i)
! hybopt: dp/deta=(1+qvapor)*(c1(i)*mut+c2(i)):
       p_inc(:,:,i) = (mu_inc*c1h(i)*(fp_one+qvapor(:,:,i)) + &
            (c1h(i)*(mu+mub)+c2h(i))*q_inc(:,:,i))*(znw(i)-znw(i+1))
       if(i < kte) then
          p_inc(:,:,i) = p_inc(:,:,i) +  p_inc(:,:,i+1)
       end if
    end do
    p = p + p_inc
    if (istep .le. 10) return
    
    ! update the geopotential
    call calc_ph_hyd_wrf(qvapor,p,pb,t,hgt,mu,mub,c3h,c4h,c3f,c4f,ptop,ph_temp) 	! get the hydrostatic geopotential
    ph_temp = ph_temp + ph_nl			! add the saved nonhydrostatic component
    ph = ph_temp - phb		! remove the base component
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("adj_wrf_derived")
#endif
end subroutine adj_wrf_derived

subroutine displace_theta_wrf(t,ph,phb,fcadisp,&
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: displace_theta_wrf
!   prgmmr: Nehrkorn
!
! abstract: Displace potential temperature field while accounting for the environmental lapse rate
!
! program history log:
!
!   input argument list: 
!       t
!       ph, phb
!       fcadisp			! displacement field generated by FCA routine
!       num_glob_needed, needed_ij_in, needed_ij_out, index_in
!       needed_wgts_out
!       interp_order
!
!   output argument list:
!       t
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
     
    implicit none
    real(fp), intent(INOUT), dimension(ims:ime,jms:jme,kms:kme) :: t
    real(fp), intent(IN), dimension(ims:ime,jms:jme,kms:(kme+1)) :: ph, phb
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    integer, intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
    real(fp), intent(in) :: needed_wgts_out(:,:)
    integer, intent(in) :: interp_order
    real(fp), dimension(ims:ime, jms:jme, kms:kme) :: ph_tot
    real(fp), dimension(ims:ime, jms:jme, kms:kme) :: TKnew, znew, zlvl
    integer :: k

#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("displace_theta_wrf")
#endif
    ph_tot = ph+phb
    do k = kts, kte ! find vertical displacement of theta mass level   
       zlvl(:,:,k) = (ph_tot(:,:,k)+ph_tot(:,:,k+1))/2/grav
       call apply_disp_2d(zlvl(:,:,k),znew(:,:,k),fcadisp,&
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    end do
    ! displace theta
    call apply_disp_theta(fcadisp,T,zlvl,znew,TKnew,&
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
    ! save the new theta to the old grid
    T = TKnew
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("displace_theta_wrf")
#endif
end subroutine displace_theta_wrf

subroutine apply_disp_theta(fcadisp,TK,zlvl,znew,TKnew, &
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: apply_disp_theta
!   prgmmr: Nehrkorn
!
! abstract: apply displacements to the 3d theta field
!
! program history log:
!
!   input argument list: 
!       fcadisp			! displacement field generated by FCA routine
!       znew, TK, zlvl          ! displaced (new) height values, original field, original height values
!       num_glob_needed, needed_ij_in, needed_ij_out, index_in
!       needed_wgts_out
!       interp_order
!
!   output argument list:
!       tknew                   ! displaced theta
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    implicit none
    type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
    real(fp), dimension(ims:ime, jms:jme, kms:kme), intent(in) :: znew, TK, zlvl
    real(fp), dimension(ims:ime, jms:jme, kms:kme), intent(out) :: TKnew
    integer, intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
    real(fp), intent(in) :: needed_wgts_out(:,:)
    integer, intent(in) :: interp_order
    integer :: i, j, k, l
    integer :: ibot, itop
    real(fp), dimension(ims:ime, jms:jme,2) :: T_bot_top ! theta above and below level for interpolation

#ifdef TRACE_USE
    if (trace_use) call da_trace_entry("apply_disp_theta")
#endif
    TKnew = -999 ! initialize TKnew as missing
    ibot=1
    ! Compute new theta at bottom level
    call apply_disp_2d(TK(:,:,1),T_bot_top(:,:,ibot),fcadisp, &
         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)

    itop=1
    do l= kts, kte-1
       ! switch top and bottom index
       ibot=itop
       if (ibot .eq. 1) then
          itop=2
       else
          itop=1
       end if
       ! Compute new theta at top level
       call apply_disp_2d(TK(:,:,l+1),T_bot_top(:,:,itop),fcadisp, &
            needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)

       do k = kts, kte
!!$          n_within=count(zlvl(:,:,k) > znew(:,:,l) .and. &
!!$               zlvl(:,:,k) <= znew(:,:,l+1))
!!$          write (*,*) 'l,k,n_within=',l,k,n_within
          ! Linearly interpolate vertically between bottom and top levels
          where (zlvl(:,:,k) > znew(:,:,l) .and. &
               zlvl(:,:,k) <= znew(:,:,l+1))
             TKnew(:,:,k) = T_bot_top(:,:,itop) * (zlvl(:,:,k)-znew(:,:,l))/(znew(:,:,l+1) - znew(:,:,l)) &
                  +  T_bot_top(:,:,ibot) * (1-(zlvl(:,:,k)-znew(:,:,l))/(znew(:,:,l+1) - znew(:,:,l)))
          end where
          if (l == kts) then
             ! For grid points with height at or below bottom-most znew (origin) level:
!!$             n_below=count(zlvl(:,:,k) <= znew(:,:,l))
!!$             write (*,*) 'k=',k,', n_below=',n_below
             where (zlvl(:,:,k) <= znew(:,:,l))
                TKnew(:,:,k) = T_bot_top(:,:,ibot)
             end where
          elseif (l == kte-1) then
             ! For grid points with new height at or above top-most level:
!!$             n_above=count(zlvl(:,:,k) >= znew(:,:,l+1))
!!$             write (*,*) 'k=',k,', n_above=',n_above
             where (zlvl(:,:,k) >= znew(:,:,l+1))
                TKnew(:,:,k) = T_bot_top(:,:,itop)
             end where
          end if
       end do
    end do
#ifdef TRACE_USE
    if (trace_use) call da_trace_exit("apply_disp_theta")
#endif
end subroutine apply_disp_theta

function sh2rh(hum,t,parr)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: sh2rh
!   prgmmr: Nehrkorn
!
! abstract: Convert mixing ratio (kg/kg) to relative humidity (%)
!           ! Formulas and constants from WRFV3.2.1 (module_initialize_real.F, Registry.EM)
!
! program history log:
!
!   input argument list: 
!    hum - mixing ratio (kg/kg)
!    t - temperature (K)
!    parr - pressure (Pa)
!
!   output argument list:
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    implicit none
    real(fp), dimension(ims:ime, jms:jme), intent(in) :: hum, t, parr
    real(fp), dimension(ims:ime, jms:jme) :: sh2rh

    integer :: i,j
    real(fp) :: r, e, esat, p
    real(fp) :: rdorv, ew, t1

    ! From module_intialize_real.F:
    real(fp),         parameter     :: t_ref       = 0.0
    real(fp),         parameter     :: mw_air      = 28.966
    real(fp),         parameter     :: mw_vap      = 18.0152

    real(fp),         parameter     :: a0       = 6.107799961
    real(fp),         parameter     :: a1       = 4.436518521e-01
    real(fp),         parameter     :: a2       = 1.428945805e-02
    real(fp),         parameter     :: a3       = 2.650648471e-04
    real(fp),         parameter     :: a4       = 3.031240396e-06
    real(fp),         parameter     :: a5       = 2.034080948e-08
    real(fp),         parameter     :: a6       = 6.136820929e-11

    real(fp),         parameter     :: es0 = 6.1121

    real(fp),         parameter     :: c1       = 9.09718
    real(fp),         parameter     :: c2       = 3.56654
    real(fp),         parameter     :: c3       = 0.876793
    real(fp),         parameter     :: eis      = 6.1071
    real(fp)                        :: rhs
    real(fp),         parameter     :: tf       = 273.16
    real(fp)                        :: tk
    real(fp),         parameter     :: const_47 = -47.
    real(fp),         parameter     :: const_17 = 17.67
    real(fp),         parameter     :: const_10 = 10.
    real(fp),         parameter     :: const_100 = 100.
    real(fp),         parameter     :: const_243 = 243.5

    rdorv = mw_vap/mw_air
    do j= jms, jme
       do i= ims, ime
          p=parr(i,j)
          r = hum(i,j)
          e = (p*r)/(rdorv + r)
          ! real formulas wrt liquid/ice:
          t1 = t(i,j) - tf
          if ( ( t1 .ge. t_ref ) .and. ( t1 .ge. const_47) ) then    ! liq phase eslo
             ew = a0 + t1 * (a1 + t1 * (a2 + t1 * (a3 + t1 * (a4 + t1 * (a5 + t1 * a6)))))
          else if ( ( t1 .ge. t_ref ) .and. ( t1 .lt. const_47 ) ) then !liq phas poor es
             ew = es0 * exp(const_17 * t1 / ( t1 + const_243))
          else
             tk = t(i,j)
             rhs = -c1 * (tf / tk - 1.) - c2 * log10(tf / tk) +  &
                  c3 * (1. - tk / tf) +      log10(eis)
             ew = const_10 ** rhs
          end if
          ! factor of 100. to convert from mb (hPa) to Pa:
          esat = const_100*ew
          sh2rh(i,j) = const_100*e/esat
          if (sh2rh(i,j) .gt. const_100) then
             sh2rh(i,j) = const_100
          end if
       end do
    end do
end function sh2rh

function rh2sh(rh,t,parr)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: rh2sh
!   prgmmr: Nehrkorn
!
! abstract: Convert  relative humidity (%) to mixing ratio (kg/kg)
!           ! Formulas and constants from WRFV3.2.1 (module_initialize_real.F, Registry.EM)
!
! program history log:
!
!   input argument list: 
!    rh - relative humidity (%)
!    t - temperature (K)
!    parr - pressure (Pa)
!
!   output argument list:
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
    implicit none
    real(fp), dimension(ims:ime, jms:jme), intent(in) :: rh, t, parr
    real(fp), dimension(ims:ime, jms:jme) :: rh2sh

    integer :: i,j
    real(fp) :: e, esat, p
    real(fp) :: rdorv, ew, t1

    ! From module_intialize_real.F:
    real(fp),         parameter     :: t_ref       = 0.0
    real(fp),         parameter     :: mw_air      = 28.966
    real(fp),         parameter     :: mw_vap      = 18.0152

    real(fp),         parameter     :: a0       = 6.107799961
    real(fp),         parameter     :: a1       = 4.436518521e-01
    real(fp),         parameter     :: a2       = 1.428945805e-02
    real(fp),         parameter     :: a3       = 2.650648471e-04
    real(fp),         parameter     :: a4       = 3.031240396e-06
    real(fp),         parameter     :: a5       = 2.034080948e-08
    real(fp),         parameter     :: a6       = 6.136820929e-11

    real(fp),         parameter     :: es0 = 6.1121

    real(fp),         parameter     :: c1       = 9.09718
    real(fp),         parameter     :: c2       = 3.56654
    real(fp),         parameter     :: c3       = 0.876793
    real(fp),         parameter     :: eis      = 6.1071
    real(fp)                        :: rhs
    real(fp),         parameter     :: tf       = 273.16
    real(fp)                        :: tk
    real(fp),         parameter     :: const_47 = -47.
    real(fp),         parameter     :: const_17 = 17.67
    real(fp),         parameter     :: const_10 = 10.
    real(fp),         parameter     :: const_100 = 100.
    real(fp),         parameter     :: const_243 = 243.5
    
    rdorv = mw_vap/mw_air
    do j= jms, jme
       do i= ims,ime
          ! real formulas wrt liquid/ice:
          t1 = t(i,j) - tf
          if ( ( t1 .ge. t_ref ) .and. ( t1 .ge. const_47) ) then    ! liq phase eslo
             ew = a0 + t1 * (a1 + t1 * (a2 + t1 * (a3 + t1 * (a4 + t1 * (a5 + t1 * a6)))))
          else if ( ( t1 .ge. t_ref ) .and. ( t1 .lt. const_47 ) ) then !liq phas poor es
             ew = es0 * exp(const_17 * t1 / ( t1 + const_243))
          else
             tk = t(i,j)
             rhs = -c1 * (tf / tk - 1.) - c2 * log10(tf / tk) +  &
                  c3 * (1. - tk / tf) +      log10(eis)
             ew = const_10 ** rhs
          end if
          esat = const_100*ew	! factor of 100. to convert from mb (hPa) to Pa
          p=parr(i,j)		! total pressure
          e = esat*rh(i,j)/const_100	! vapor pressure ; scale percent RH to decimal
          rh2sh(i,j) = rdorv*e/(p-e)	! mixing ratio
       end do
    end do
end function rh2sh

#ifdef FCA_REF_MOD
end module displace_wrf_m
#endif

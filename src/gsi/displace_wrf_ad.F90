#ifdef FCA_REF_MOD
module displace_wrf_ad_m
!$$$ module documentation block
!           .      .    .                                       .
! module:   displace_wrf_ad_m
!  prgmmr: Nehrkorn
!
! abstract: Horizontally displace WRF model fields, adjoint (AD) version
!
! program history log:
!
! subroutines included:
!   sub displace_wrf_fields_ad
!   sub calc_ph_hyd_wrf_ad
!   sub adj_wrf_derived_ad
!   sub displace_theta_wrf_ad
!   sub apply_disp_theta_ad
!   sub sh2rh_ad
!   sub rh2sh_ad
!
! functions included:
!
! variable definition:
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
  use kinds, only: r_kind, i_kind
  use core_disp_types_m, only: fca_gridded_disp, ims,ime,jms,jme,kms,kme,its,ite,jts,jte,kts,kte
  use core_disp_func_ad_m, only: apply_disp_2d_ad, apply_vert_ad
  use core_disp_func_m, only: apply_disp_2d, apply_vert
  use displace_wrf_m, only: calc_ph_hyd_wrf, adj_wrf_derived, displace_theta_wrf, apply_disp_theta, sh2rh, rh2sh, &
       t0, p0, gas_constant, gas_constant_v, gravity, grav, Rd, Rv, cp, kappa, base_pres, gamma

  implicit none
  private
  public :: displace_wrf_fields_ad
  contains
#else
#define TRACE_USE
#endif

SUBROUTINE DISPLACE_WRF_FIELDS_AD(th_compute, istep, qv_ind, moist, nmoist, moist_ad&
     , p, p_ad, pb, t, t_ad, ph, ph_ad, phb, u, u_ad, v, v_ad, w, w_ad, &
     hgt, mub, mu, mu_ad, psfc, psfc_ad, znu, znw, c1h, c2h, c3h, c4h, c3f, c4f, ptop, fcadisp, fcadisp_ad,&
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: displace_wrf_fields_ad
!   prgmmr: Nehrkorn
!
! abstract: Horizontally displace WRF model fields
!
! program history log:
!
!   input argument list: 
!      th_compute				! control parameter for theta computation/displacemnt
!      istep				! control parameter for theta computation/displacemnt
!      qv_ind				! index for qvapor
!      nmoist ! number of moisture fields
!      p, pb, t, u, v, w
!      ph, phb, ph_ad
!      p_ad, t_ad, u_ad, v_ad, w_ad
!      moist
!      moist_ad
!      hgt, mub
!      mu, psfc
!      mu_ad, psfc_ad
!      znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
!      ptop
!      fcadisp			! displacement field generated by FCA routine
!      fcadisp_ad		! displacement field generated by FCA routine
!      num_glob_needed, needed_ij_in, needed_ij_out, index_in
!      needed_wgts_out
!      interp_order
!
!   output argument list:
!      p, pb, t, u, v, w
!      ph, phb, ph_ad
!      p_ad, t_ad, u_ad, v_ad, w_ad
!      moist
!      moist_ad
!      mu, psfc
!      mu_ad, psfc_ad
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
  IMPLICIT NONE
  ! control parameter for theta computation/displacemnt
  INTEGER(I_KIND), INTENT(IN) :: th_compute
  integer(i_kind), intent(in) :: istep
  ! index for qvapor
  INTEGER(I_KIND), INTENT(IN) :: qv_ind, nmoist
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: p, pb, t, u, v, w
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: ph_ad, ph, phb
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: p_ad, t_ad, u_ad, v_ad, w_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme, 1:nmoist), INTENT(INOUT) :: moist
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme, 1:nmoist) :: moist_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: hgt, mub
  real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: mu, psfc
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: mu_ad, psfc_ad
  real(r_kind), DIMENSION(kms:kme), INTENT(IN) :: znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
  real(r_kind), INTENT(IN) :: ptop
  type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
  type (fca_gridded_disp), intent(inout) :: fcadisp_ad		! displacement field generated by FCA routine
  integer(i_kind), intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
  real(r_kind), intent(in) :: needed_wgts_out(:,:)
  integer(i_kind), intent(in) :: interp_order
  ! hydrostatic component for geopotential
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_hyd, ph_nl
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_hyd_ad, ph_nl_ad
  ! work space for 2d original/displaced fields
  real(r_kind), DIMENSION(ims:ime, jms:jme, 2) :: work2d
  real(r_kind), DIMENSION(ims:ime, jms:jme, 2) :: work2d_ad
  integer(i_kind) :: ISIZE2OFu, ISIZE1OFu, ISIZE3OFu, ISIZE2OFv, ISIZE1OFv, ISIZE3OFv, &
       ISIZE2OFw, ISIZE1OFw, ISIZE3OFw, ISIZE3OFmoist, ISIZE2OFmoist, ISIZE1OFmoist

  INTEGER(I_KIND) :: i, status
  INTEGER(I_KIND) :: result1
  INTEGER(I_KIND) :: branch

#ifdef TRACE_USE
  if (trace_use) call da_trace_entry("displace_wrf_fields_ad")
#endif
  
  ISIZE2OFu=size(u,2)
  ISIZE1OFu=size(u,1)
  ISIZE3OFu=size(u,3)
  ISIZE2OFv=size(v,2)
  ISIZE1OFv=size(v,1)
  ISIZE3OFv=size(v,3)
  ISIZE2OFw=size(w,2)
  ISIZE1OFw=size(w,1)
  ISIZE3OFw=size(w,3)
  ISIZE3OFmoist=size(moist,3)
  ISIZE2OFmoist=size(moist,2)
  ISIZE1OFmoist=size(moist,1)

  ! zero out local adjoint arrays:
  ph_hyd_ad=0._r_kind
  ph_nl_ad=0._r_kind
  work2d_ad=0._r_kind

  ! we need the nonhydrostatic component of the geopotential to apply after displacements to get the total PH
  ! Before doing anything with the displacements, get the hydrostatic component of the geopotential
  CALL CALC_PH_HYD_WRF(moist(:, :, :, qv_ind), p, pb, t, hgt, mu, mub&
       , c3h,c4h,c3f,c4f, ptop, ph_hyd)
  ! save the nonhydrostatic component for later use
  ph_nl = ph + phb - ph_hyd
  CALL PUSHREAL4ARRAY(u(ims,jms,kms), r_kind*ISIZE3OFu*ISIZE1OFu*ISIZE2OFu/4)
  ! Adjust fields which are to be directly displaced (momentum and hydrometeor mixing ratios)
  CALL APPLY_VERT(u, 0, work2d, fcadisp,&
       needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
  if (istep > 1) then
     CALL PUSHREAL4ARRAY(v(ims,jms,kms), r_kind*ISIZE3OFv*ISIZE1OFv*ISIZE2OFv/4)
     CALL APPLY_VERT(v, 0, work2d, fcadisp,&
          needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
     if (istep > 2) then
        CALL PUSHREAL4ARRAY(w(ims,jms,kms), r_kind*ISIZE3OFw*ISIZE1OFw*ISIZE2OFw/4)
    ! NOT: Only apply displacements to first kte levels, even for staggered variables w, ph_nl
	CALL APPLY_VERT(w, 1, work2d, fcadisp,&
             needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
        if (istep > 3) then
	   CALL PUSHREAL4ARRAY(ph_nl(ims,jms,kms), r_kind*SIZE(ph, 1)*SIZE(ph, 2)*SIZE(ph, &
                3)/4)
           CALL APPLY_VERT(ph_nl, 1, work2d, fcadisp,&
                needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
           if (istep > 4) then
              result1 = SIZE(moist, 4)
              DO i=1,result1
                 IF (i /= qv_ind) THEN
		    CALL PUSHREAL4ARRAY(moist(ims, jms, kms, i), r_kind*ISIZE1OFmoist*&
                         ISIZE2OFmoist*ISIZE3OFmoist/4)
                    CALL APPLY_VERT(moist(:, :, :, i), 0, work2d, fcadisp,&
                         needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
                 END IF
              END DO
	      
              if (istep > 5) then
	         CALL ADJ_WRF_DERIVED_AD(moist(:, :, :, qv_ind), moist_ad(:, :, :, &
                      qv_ind), p, p_ad, pb, t, t_ad, ph, ph_ad, phb, &
                      ph_nl, ph_nl_ad, hgt, mub, mu, mu_ad, psfc, &
                      psfc_ad, znu, znw, c1h, c2h, c3h, c4h, c3f, c4f, ptop, &
                      th_compute, fcadisp, fcadisp_ad, istep,&
                      needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
	      endif ! > 5
	     
              DO i=result1,1,-1
                 IF (i /= qv_ind) THEN
		    CALL POPREAL4ARRAY(moist(ims, jms, kms, i), r_kind*ISIZE1OFmoist*&
                         ISIZE2OFmoist*ISIZE3OFmoist/4)
		    CALL APPLY_VERT_AD(moist(:, :, :, i), moist_ad(:, :, :, i), 0, &
                         work2d, work2d_ad, fcadisp, fcadisp_ad, interp_order)
                 END IF
              END DO
	      
           endif ! > 4
	   CALL POPREAL4ARRAY(ph_nl(ims,jms,kms), r_kind*SIZE(ph, 1)*SIZE(ph, 2)*SIZE(ph, 3&
                )/4)
	   CALL APPLY_VERT_AD(ph_nl, ph_nl_ad, 1, work2d, work2d_ad, fcadisp, fcadisp_ad, interp_order)
	   
        endif ! > 3
        CALL POPREAL4ARRAY(w(ims,jms,kms), r_kind*ISIZE3OFw*ISIZE1OFw*ISIZE2OFw/4)
	CALL APPLY_VERT_AD(w, w_ad, 1, work2d, work2d_ad, fcadisp, fcadisp_ad, interp_order)
	
     endif ! > 2
     CALL POPREAL4ARRAY(v(ims,jms,kms), r_kind*ISIZE3OFv*ISIZE1OFv*ISIZE2OFv/4)
     CALL APPLY_VERT_AD(v, v_ad, 0, work2d, work2d_ad, fcadisp, fcadisp_ad, interp_order)
  endif ! > 1
  CALL POPREAL4ARRAY(u(ims,jms,kms), r_kind*ISIZE3OFu*ISIZE1OFu*ISIZE2OFu/4)
  CALL APPLY_VERT_AD(u, u_ad, 0, work2d, work2d_ad, fcadisp, fcadisp_ad, interp_order)
  ph_hyd_ad = 0._r_kind
  ph_ad = ph_ad + ph_nl_ad
  ph_hyd_ad = -ph_nl_ad
  CALL CALC_PH_HYD_WRF_AD(moist(:, :, :, qv_ind), moist_ad(:, :, :, &
       qv_ind), p, p_ad, pb, t, t_ad, hgt, mu, mu_ad, mub&
       ,c3h,c4h,c3f,c4f, ptop, ph_hyd, ph_hyd_ad)
#ifdef TRACE_USE
  if (trace_use) call da_trace_exit("displace_wrf_fields_ad")
#endif
END SUBROUTINE DISPLACE_WRF_FIELDS_AD

SUBROUTINE CALC_PH_HYD_WRF_AD(qvapor, qvapor_ad, p, p_ad, pb, t, t_ad&
     , hgt, mu, mu_ad, mub,c3h,c4h,c3f,c4f, ptop, ph_hyd, ph_hyd_ad)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: calc_ph_hyd_wrf_ad
!   prgmmr: Nehrkorn
!
! abstract: compute hydrostatic geopotential height
!
! program history log:
!
!   input argument list: 
!       qvapor, p, pb, t
!       qvapor_ad, p_ad, t_ad
!       hgt, mu, mub
!       mu_ad
!       c3h,c4h,c3f,c4f
!       ptop
!
!   output argument list:
!       ph_hyd, ph_hyd_ad
!       qvapor_ad, p_ad, t_ad
!       mu_ad
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
  IMPLICIT NONE
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(IN) :: qvapor, p, pb, t
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: qvapor_ad, p_ad, t_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: hgt, mu, mub
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: mu_ad
  real(r_kind), DIMENSION(kms:kme), INTENT(IN) :: c3h,c4h,c3f,c4f
  real(r_kind), INTENT(IN) :: ptop
  ! nonhydrostatic component for geopotential
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_hyd
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_hyd_ad
  INTEGER(I_KIND) :: i
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: rhod
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: rhod_ad
  real(r_kind), dimension(ims:ime,jms:jme) :: pfu,pfd,phm
  real(r_kind), dimension(ims:ime,jms:jme) :: pfu_ad,pfd_ad,phm_ad
  ! model Eta vertical levels
!!$  real(r_kind) :: deta(SIZE(znu)), znuw(size(znu)+1)
  real(r_kind) :: temp3
  real(r_kind) :: temp2(ims:ime, jms:jme, kms:kme)
  real(r_kind) :: temp1(ims:ime, jms:jme, kms:kme)
  real(r_kind) :: temp0(ims:ime, jms:jme, kms:kme)
  real(r_kind) :: temp1_ad(ims:ime, jms:jme, kms:kme)
  real(r_kind) :: temp4_ad(ims:ime, jms:jme)
  INTRINSIC SIZE
  real(r_kind) :: temp_ad(ims:ime, jms:jme, kms:kme)
  real(r_kind) :: temp(ims:ime, jms:jme, kms:kme)
  
#ifdef TRACE_USE
  if (trace_use) call da_trace_entry("calc_ph_hyd_wrf_ad")
#endif
  
  rhod(:,:,kts:kte) = (p(:,:,kts:kte)+pb(:,:,kts:kte))*(1_r_kind-rv/rd*qvapor(:,:,kts:kte))/&
       (rd*(t(:,:,kts:kte)+t0)*((p(:,:,kts:kte)+pb(:,:,kts:kte))/p0)**(rd/cp))
  
  rhod_ad = 0.0_r_kind
  phm_ad(:,:)=0_r_kind
  pfd_ad(:,:)=0_r_kind
  pfu_ad(:,:)=0_r_kind
  DO i=kte+1,kts+1,-1
     pfu(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i)  +C4F(i)
     pfd(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i-1)+C4F(i-1)
     phm(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3H(i-1)+C4H(i-1)
     temp4_ad = ph_hyd_ad(:, :, i)
     ph_hyd_ad(:, :, i-1) = ph_hyd_ad(:, :, i-1) + ph_hyd_ad(:, :, i)
     rhod_ad(:,:,i-1) = rhod_ad(:,:,i-1) - temp4_ad*phm(:,:)*log(pfd(:,:)/pfu(:,:))/rhod(:,:,i-1)**2
     phm_ad(:,:)=phm_ad(:,:) + (temp4_ad/rhod(:,:,i-1))*log(pfd(:,:)/pfu(:,:))
     pfd_ad(:,:)=pfd_ad(:,:) + (temp4_ad*phm(:,:)/rhod(:,:,i-1))/pfd(:,:)
     pfu_ad(:,:)=pfu_ad(:,:) - (temp4_ad*phm(:,:)/rhod(:,:,i-1))/pfu(:,:)
     MU_ad(:,:) = MU_ad(:,:) + pfu_ad(:,:)*C3F(i)
     MU_ad(:,:) = MU_ad(:,:) + pfd_ad(:,:)*C3F(i-1)
     MU_ad(:,:) = MU_ad(:,:) + phm_ad(:,:)*C3H(i-1)
     phm_ad(:,:)=0_r_kind
     pfd_ad(:,:)=0_r_kind
     pfu_ad(:,:)=0_r_kind
     ph_hyd_ad(:, :, i) = 0.0_r_kind
  END DO
  
  temp3 = rd/cp
  temp2(:,:,kts:kte) = (pb(:,:,kts:kte)+p(:,:,kts:kte))/p0
  temp1(:,:,kts:kte) = temp2(:,:,kts:kte)**temp3
  temp(:,:,kts:kte) = rd*(t(:,:,kts:kte)+t0)*temp1(:,:,kts:kte)
  temp1_ad(:,:,kts:kte) = rhod_ad(:,:,kts:kte)/temp(:,:,kts:kte)
  temp0(:,:,kts:kte) = -(rv*qvapor(:,:,kts:kte)/rd) + 1
  temp_ad(:,:,kts:kte) = -((pb(:,:,kts:kte)+p(:,:,kts:kte))*temp0(:,:,kts:kte)*temp1_ad(:,:,kts:kte)/temp(:,:,kts:kte))
  
  WHERE (temp2(:,:,kts:kte) <= 0.0_r_kind .AND. (temp3 == 0.0_r_kind .OR. temp3 /= INT(&
       temp3))) 
     p_ad(:,:,kts:kte) = p_ad(:,:,kts:kte) + temp0(:,:,kts:kte)*temp1_ad(:,:,kts:kte)
  ELSEWHERE
     p_ad(:,:,kts:kte) = p_ad(:,:,kts:kte) + temp3*temp2(:,:,kts:kte)**(temp3-1)*rd*(t(:,:,kts:kte)+t0)*&
          temp_ad(:,:,kts:kte)/p0 + temp0(:,:,kts:kte)*temp1_ad(:,:,kts:kte)
  END WHERE
  
  qvapor_ad(:,:,kts:kte) = qvapor_ad(:,:,kts:kte) - rv*(pb(:,:,kts:kte)+p(:,:,kts:kte))*temp1_ad(:,:,kts:kte)/rd
  t_ad(:,:,kts:kte) = t_ad(:,:,kts:kte) + rd*temp1(:,:,kts:kte)*temp_ad(:,:,kts:kte)
#ifdef TRACE_USE
  if (trace_use) call da_trace_exit("calc_ph_hyd_wrf_ad")
#endif
END SUBROUTINE CALC_PH_HYD_WRF_AD

SUBROUTINE ADJ_WRF_DERIVED_AD(qvapor, qvapor_ad, p, p_ad, pb, t, t_ad&
     , ph, ph_ad, phb, ph_nl, ph_nl_ad, hgt, mub, mu, mu_ad, psfc, &
     psfc_ad, znu, znw, c1h, c2h, c3h, c4h, c3f, c4f, ptop, th_compute, fcadisp, fcadisp_ad, istep,&
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: adj_wrf_derived_ad
!   prgmmr: Nehrkorn
!
! abstract: Compute secondary fields from adjusted fields
!           Requires surface pressure and water vapor increments
!
! program history log:
!
!   input argument list: 
!       qvapor, p, pb, t, ph, qvapor_ad, p_ad, t_ad, ph_ad
!       ph_nl, phb, ph_nl_ad
!       hgt, mub
!       mu, psfc, mu_ad, psfc_ad
!       znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
!       ptop
!       fcadisp			! displacement field generated by FCA routine
!       fcadisp_ad			! displacement field generated by FCA routine
!       th_compute				! control parameter for theta computation/displacemnt
!       istep
!       num_glob_needed, needed_ij_in, needed_ij_out, index_in
!       needed_wgts_out
!       interp_order
!
!   output argument list:
!       qvapor, p, pb, t, ph, qvapor_ad, p_ad, t_ad, ph_ad
!       mu, psfc, mu_ad, psfc_ad
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block

  IMPLICIT NONE
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: qvapor, p, pb, t
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: ph
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: qvapor_ad, p_ad, t_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(IN) :: ph_nl, phb
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_nl_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: hgt, mub
  real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(INOUT) :: mu, psfc
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: mu_ad, psfc_ad
  real(r_kind), DIMENSION(kms:kme), INTENT(IN) :: znu, znw, c1h, c2h, c3h, c4h, c3f, c4f
  real(r_kind), INTENT(IN) :: ptop
  type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
  type (fca_gridded_disp), intent(inout) :: fcadisp_ad		! displacement field generated by FCA routine
  ! control parameter for theta computation/displacemnt
  INTEGER(I_KIND), INTENT(IN) :: th_compute
  integer(i_kind), intent(in) :: istep
  integer(i_kind), intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
  real(r_kind), intent(in) :: needed_wgts_out(:,:)
  integer(i_kind), intent(in) :: interp_order
  integer(i_kind) :: ISIZE2OFt, ISIZE1OFt, ISIZE3OFt, ISIZE2OFqvapor, ISIZE3OFqvapor, ISIZE1OFqvapor, &
       ISIZE1OFmu, ISIZE2OFmu, ISIZE2OFp, ISIZE1OFp, ISIZE3OFp
  INTEGER(I_KIND) :: i, j, k, q_ind, numvars=1
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: tk, ptot, p_inc, q_inc
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: tk_ad, &
       ptot_ad, p_inc_ad, q_inc_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_temp
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_temp_ad
  ! model Eta vertical levels
  real(r_kind), dimension(ims:ime,jms:jme) :: pfu,pfd,phm
  real(r_kind), dimension(ims:ime,jms:jme) :: pfu_ad,pfd_ad,phm_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: sum1, sum2, sum3
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: sum1_ad, sum2_ad, sum3_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme, 2) :: work2d
  real(r_kind), DIMENSION(ims:ime, jms:jme, 2) :: work2d_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: tbl, ts, tm, zl, tslv&
       , pslv, ps_inc, mu_inc
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: tbl_ad, ts_ad, tm_ad&
       , zl_ad, tslv_ad, pslv_ad, ps_inc_ad, mu_inc_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: result1
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: result1_ad
  INTEGER(I_KIND) :: branch
  real(r_kind) :: temp3
  real(r_kind) :: temp2
  real(r_kind) :: temp0_ad
  real(r_kind) :: temp1
  real(r_kind) :: temp0
  INTRINSIC EXP
  real(r_kind) :: temp1_ad
  real(r_kind) :: temp15_ad(ims:ime, jms:jme)
  real(r_kind) :: temp18(ims:ime, jms:jme)
  real(r_kind) :: temp17(ims:ime, jms:jme)
  real(r_kind) :: temp16(ims:ime, jms:jme)
  real(r_kind) :: temp15(ims:ime, jms:jme)
  real(r_kind) :: temp14(ims:ime, jms:jme)
  real(r_kind) :: temp4_ad
  real(r_kind) :: temp13(ims:ime, jms:jme)
  real(r_kind) :: temp12(ims:ime, jms:jme)
  real(r_kind) :: temp11(ims:ime, jms:jme)
  real(r_kind) :: temp10
  INTRINSIC SIZE
  real(r_kind) :: temp19_ad(ims:ime, jms:jme)
  real(r_kind) :: temp7_ad
  INTRINSIC LOG
  real(r_kind) :: temp19_ad0(ims:ime, jms:jme)
  real(r_kind) :: temp11_ad(ims:ime, jms:jme)
  real(r_kind) :: temp9_ad(ims:ime, jms:jme)
  real(r_kind) :: temp12_ad(ims:ime, jms:jme)
  real(r_kind) :: temp
  real(r_kind) :: temp9(ims:ime, jms:jme)
  real(r_kind) :: temp8
  real(r_kind) :: temp7
  real(r_kind) :: temp6
  real(r_kind) :: temp5
  real(r_kind) :: temp4
  real(r_kind), parameter :: fp_zero=0._r_kind, fp_one=1._r_kind, fp_two=2._r_kind, p100mbPa=10000._r_kind

#ifdef TRACE_USE
  if (trace_use) call da_trace_entry("adj_wrf_derived_ad")
#endif
  ISIZE2OFt=size(t,2)
  ISIZE1OFt=size(t,1)
  ISIZE3OFt=size(t,3)
  ISIZE2OFqvapor=size(qvapor,2)
  ISIZE3OFqvapor=size(qvapor,3)
  ISIZE1OFqvapor=size(qvapor,1)
  ISIZE1OFmu=size(mu,1)
  ISIZE2OFmu=size(mu,2)
  ISIZE2OFp=size(p,2)
  ISIZE1OFp=size(p,1)
  ISIZE3OFp=size(p,3)

  !zero all local _ad arrays and variables
  tk_ad=0._r_kind
  ptot_ad=0._r_kind
  p_inc_ad=0._r_kind
  q_inc_ad=0._r_kind
  ph_temp_ad=0._r_kind
  sum1_ad=0._r_kind
  sum2_ad=0._r_kind
  sum3_ad=0._r_kind
  work2d_ad=0._r_kind
  tbl_ad=0._r_kind
  ts_ad=0._r_kind
  tm_ad=0._r_kind
  zl_ad=0._r_kind
  tslv_ad=0._r_kind
  pslv_ad=0._r_kind
  ps_inc_ad=0._r_kind
  mu_inc_ad=0._r_kind
  result1_ad=0._r_kind
  temp0_ad=0._r_kind
  temp1_ad=0._r_kind
  temp15_ad=0._r_kind
  temp4_ad=0._r_kind
  temp19_ad=0._r_kind
  temp7_ad=0._r_kind
  temp19_ad0=0._r_kind
  temp11_ad=0._r_kind
  temp9_ad=0._r_kind
  temp12_ad=0._r_kind

  Ptot(:,:,kts:kte) = (p(:,:,kts:kte)+pb(:,:,kts:kte))
  TK(:,:,kts:kte) = (T(:,:,kts:kte)+t0)*(Ptot(:,:,kts:kte)/p0)**(Rd/Cp)	! Use un-displaced temperature (K) for all conversions below
  IF (th_compute == 1) THEN
     CALL PUSHREAL4ARRAY(t(ims,jms,kms), r_kind*ISIZE3OFt*ISIZE1OFt*ISIZE2OFt/4)
     CALL DISPLACE_THETA_WRF(t, ph, phb, fcadisp,&
          needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
  ELSE
     CALL PUSHREAL4ARRAY(t(ims,jms,kms), r_kind*ISIZE3OFt*ISIZE1OFt*ISIZE2OFt/4)
     CALL PUSHREAL4ARRAY(t, r_kind*ISIZE3OFt*ISIZE1OFt*ISIZE2OFt/4)
     call apply_vert(t,0,work2d,fcadisp,&
          needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
  END IF

  if (istep > 6) then
     ! Find the temperature 100 mb AGL
     DO i= ims, ime
        DO j= jms, jme
           ! first check is top model level is top of PBL -- very unlikely but included for robustness
           IF (ptot(i, j, kte) == psfc(i, j) - p100mbPa) THEN
              tbl(i, j) = tk(i, j, kte)
              CALL PUSHINTEGER4(1)
           ELSE
              CALL PUSHINTEGER4(0)
           END IF
           DO k= kts,kte-1
              IF (ptot(i, j, k+1) == psfc(i, j) - p100mbPa) THEN
                 tbl(i, j) = tk(i, j, k+1)
                 CALL PUSHINTEGER4(2)
              ELSE IF (ptot(i, j, k) > psfc(i, j) - p100mbPa .AND. ptot(i, j&
                   , k+1) < psfc(i, j) - p100mbPa) THEN
                 tbl(i, j) = (tk(i, j, k+1)*LOG(ptot(i, j, k)/(psfc(i, j)-&
                      p100mbPa))+tk(i, j, k)*LOG((psfc(i, j)-p100mbPa)/ptot(i, j, k+1)&
                      ))/LOG(ptot(i, j, k)/ptot(i, j, k+1))
                 CALL PUSHINTEGER4(4)
              ELSE
                 CALL PUSHINTEGER4(3)
              END IF
           END DO
        END DO
     END DO
     ts = tbl*(psfc/(psfc-p100mbPa))**(rd*gamma/grav)
     !mean 100mb layer temperature
     tm = (tbl+ts)/fp_two
     !Height AGL for 100mb AGL
     zl = hgt - rd/grav*LOG((psfc-p100mbPa)/psfc)*tm
     tslv = tbl + gamma*zl
     !sea-level pressure
     pslv = psfc*EXP(grav*hgt/(rd*(ts+tslv)/fp_two))
     ! Now perform displacement of sea level pressure
     call apply_disp_2d(Pslv,work2d(:,:,1),fcadisp,&
          needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
     CALL PUSHREAL4ARRAY(work2d(ims, jms, 2), r_kind*SIZE(p, 1)*SIZE(p, 2)/4&
          )
     work2d(:, :, 2) = work2d(:, :, 1)/EXP(grav*hgt/(rd*(ts+tslv)/fp_two))
     ! get the surface pressure increment
     ps_inc = work2d(:, :, 2) - psfc
     if (istep > 7) then
        ! Store the new Psfc
        DO k= kts, kte
           CALL PUSHREAL4ARRAY(work2d(ims, jms, 1), r_kind*SIZE(p, 1)*SIZE(p, 2)&
                /4)
           work2d(:, :, 1) = SH2RH(qvapor(:, :, k), tk(:, :, k), ptot(:, :, k&
                ))
           call apply_disp_2d(work2d(:,:,1),q_inc(:,:,k),fcadisp,&
                needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
           ! calculate and store increments using q from the adjusted RH
           result1 = RH2SH(q_inc(:, :, k), tk(:, :, k), ptot(:, :, k))
	   CALL PUSHREAL4ARRAY(q_inc(ims, jms, k), r_kind*SIZE(p, 1)*SIZE(p, 2)/&
                4)
           q_inc(:, :, k) = result1 - qvapor(:, :, k)
        END DO
	CALL PUSHREAL4ARRAY(qvapor(ims,jms,kms), r_kind*ISIZE1OFqvapor*ISIZE3OFqvapor*&
             ISIZE2OFqvapor/4)
        qvapor(:, :, :) = qvapor(:, :, :) + q_inc
        if (istep > 8) then

           sum1 = fp_zero
           sum2 = fp_zero
           sum3 = fp_zero
           DO i= kte, kts, -1
              pfu(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i+1)+C4F(i+1)
              pfd(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i)  +C4F(i)
              phm(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3H(i)  +C4H(i)
              sum1 = sum1 + q_inc(:,:,i)*phm(:,:)*log(pfd(:,:)/pfu(:,:))
              sum2 = sum2 + (fp_one+qvapor(:,:,i))*phm(:,:)*log(pfd(:,:)/pfu(:,:))
              sum3 = sum3 + phm(:,:)*log(pfd(:,:)/pfu(:,:))
           END DO
           mu_inc = sum3*(ps_inc-sum1)/sum2
           CALL PUSHREAL4ARRAY(mu(ims,jms), r_kind*ISIZE2OFmu*ISIZE1OFmu/4)
           ! Update the dry air mass
           mu = mu + mu_inc
           if (istep > 9) then
              DO i= kte, kts, -1
                 p_inc(:,:,i) = (mu_inc*c1h(i)*(fp_one+qvapor(:,:,i)) + &
                      (c1h(i)*(mu+mub)+c2h(i))*q_inc(:,:,i))*(znw(i)-znw(i+1))
                 IF (i < kte) THEN
                    p_inc(:, :, i) = p_inc(:, :, i) + p_inc(:, :, i+1)
                    CALL PUSHINTEGER4(2)
                 ELSE
                    CALL PUSHINTEGER4(1)
                 END IF
              END DO
	      CALL PUSHREAL4ARRAY(p(ims,jms,kms), r_kind*ISIZE3OFp*ISIZE1OFp*ISIZE2OFp/4)
              p = p + p_inc
              if (istep > 10) then
                 ! get the hydrostatic geopotential
                 ! add the saved nonhydrostatic component
                 ! remove the base component
                 ph_temp_ad = 0.0_r_kind
                 ph_temp_ad = ph_ad
                 ph_nl_ad = 0.0_r_kind
                 ph_nl_ad = ph_temp_ad
		 ! no pushing or popping in CALC_PH_HYD_WRF_AD
                 CALL CALC_PH_HYD_WRF_AD(qvapor, qvapor_ad, p, p_ad, pb, t, t_ad, hgt&
                      , mu, mu_ad, mub, c3h,c4h,c3f,c4f, ptop, ph_temp, ph_temp_ad)
              endif !istep > 10
              p_inc_ad = 0.0_r_kind
              CALL POPREAL4ARRAY(p(ims,jms,kms), r_kind*ISIZE3OFp*ISIZE1OFp*ISIZE2OFp/4)
              p_inc_ad = p_ad
              q_inc_ad = 0.0_r_kind
              mu_inc_ad = 0.0_r_kind
              DO i= kts, kte, 1
                 CALL POPINTEGER4(branch)
                 IF (.NOT.branch < 2) p_inc_ad(:, :, i+1) = p_inc_ad(:, :, i+1) &
                      + p_inc_ad(:, :, i)
                 temp19_ad0 = (znw(i)-znw(i+1))*p_inc_ad(:, :, i)
                 mu_inc_ad = mu_inc_ad + (qvapor(:, :, i)+1)*c1h(i)*temp19_ad0
                 qvapor_ad(:, :, i) = qvapor_ad(:, :, i) + mu_inc*c1h(i)*temp19_ad0
                 mu_ad = mu_ad + q_inc(:, :, i)*c1h(i)*temp19_ad0
                 q_inc_ad(:, :, i) = q_inc_ad(:, :, i) + (c1h(i)*(mub+mu)+c2h(i))*temp19_ad0
                 p_inc_ad(:, :, i) = 0.0_r_kind
              END DO
           endif !istep > 9
           CALL POPREAL4ARRAY(mu(ims,jms), r_kind*ISIZE2OFmu*ISIZE1OFmu/4)
           mu_inc_ad = mu_inc_ad + mu_ad
           sum1_ad = 0.0_r_kind
           sum2_ad = 0.0_r_kind
           sum3_ad = 0.0_r_kind
           ps_inc_ad = 0.0_r_kind
           temp19_ad = mu_inc_ad/sum2
           ps_inc_ad = sum3*temp19_ad
           sum1_ad = -sum3*temp19_ad
           sum2_ad = -sum3*(ps_inc-sum1)*temp19_ad/sum2
           sum3_ad = (ps_inc-sum1)*temp19_ad
        endif !istep > 8
	
        pfu_ad(:,:) = 0.0_r_kind
        pfd_ad(:,:) = 0.0_r_kind
        phm_ad(:,:) = 0.0_r_kind
        DO i= kts, kte, 1
           pfu(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i+1)+C4F(i+1)
           pfd(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3F(i)  +C4F(i)
           phm(:,:) = PTOP+(MU(:,:)+MUB(:,:))*C3H(i)  +C4H(i)
           ! adj of sum3_tl statement
           phm_ad(:, :) = phm_ad(:, :) + sum3_ad*log(pfd(:,:)/pfu(:,:))
           pfd_ad(:, :) = pfd_ad(:, :) + sum3_ad*phm(:,:)/pfd(:,:)
           pfu_ad(:, :) = pfu_ad(:, :) - sum3_ad*phm(:,:)/pfu(:,:)
           ! adj of sum2_tl statement
           phm_ad(:, :) = phm_ad(:, :) + sum2_ad*(fp_one+qvapor(:,:,i))*log(pfd(:,:)/pfu(:,:))
           pfd_ad(:, :) = pfd_ad(:, :) + sum2_ad*(fp_one+qvapor(:,:,i))*phm(:,:)/pfd(:,:)
           pfu_ad(:, :) = pfu_ad(:, :) - sum2_ad*(fp_one+qvapor(:,:,i))*phm(:,:)/pfu(:,:)
           qvapor_ad(:, :, i) = qvapor_ad(:, :, i) + sum2_ad*phm(:,:)*log(pfd(:,:)/pfu(:,:))
           ! adj of sum1_tl statement
           phm_ad(:, :) = phm_ad(:, :) + sum1_ad*(q_inc(:,:,i))*log(pfd(:,:)/pfu(:,:))
           pfd_ad(:, :) = pfd_ad(:, :) + sum1_ad*(q_inc(:,:,i))*phm(:,:)/pfd(:,:)
           pfu_ad(:, :) = pfu_ad(:, :) - sum1_ad*(q_inc(:,:,i))*phm(:,:)/pfu(:,:)
           q_inc_ad(:, :, i) = q_inc_ad(:, :, i) + sum1_ad*phm(:,:)*log(pfd(:,:)/pfu(:,:))
           ! adj of pmh_tl, pfd_tl, pfu_tl statements:
           mu_ad(:,:) = mu_ad(:,:) + phm_ad(:,:)*C3H(i)
           mu_ad(:,:) = mu_ad(:,:) + pfd_ad(:,:)*C3F(i)
           mu_ad(:,:) = mu_ad(:,:) + pfu_ad(:,:)*C3F(i+1)
           phm_ad(:,:) = 0.0_r_kind
           pfd_ad(:,:) = 0.0_r_kind
           pfu_ad(:,:) = 0.0_r_kind
        END DO
        CALL POPREAL4ARRAY(qvapor(ims,jms,kms), r_kind*ISIZE1OFqvapor*ISIZE3OFqvapor*&
             ISIZE2OFqvapor/4)
              
	q_inc_ad = q_inc_ad + qvapor_ad(:, :, :)
        
        tk_ad = 0.0_r_kind
        ptot_ad = 0.0_r_kind
        work2d_ad = 0.0_r_kind
	DO k= kte, kts, -1
           result1_ad = 0.0_r_kind
	   CALL POPREAL4ARRAY(q_inc(ims, jms, k), r_kind*SIZE(p, 1)*SIZE(p, 2)/4&
                )
	   result1_ad = q_inc_ad(:, :, k)
           qvapor_ad(:, :, k) = qvapor_ad(:, :, k) - q_inc_ad(:, :, k)
           q_inc_ad(:, :, k) = 0.0_r_kind
           CALL RH2SH_AD0(q_inc(:, :, k), q_inc_ad(:, :, k), tk(:, :, k), &
                tk_ad(:, :, k), ptot(:, :, k), ptot_ad(:, :, k), &
                result1_ad)
	   CALL APPLY_DISP_2D_AD(work2d(:, :, 1), fcadisp, q_inc_ad(:, :, k), fcadisp_ad, interp_order)
	   CALL POPREAL4ARRAY(work2d(ims, jms, 1), r_kind*SIZE(p, 1)*SIZE(p, 2)/&
                4)
           CALL SH2RH_AD0(qvapor(:, :, k), qvapor_ad(:, :, k), tk(:, :, k), &
                tk_ad(:, :, k), ptot(:, :, k), ptot_ad(:, :, k), &
                work2d_ad(:, :, 1))
           work2d_ad(:, :, 1) = 0.0_r_kind
        END DO
	
     endif !(istep > 7)
     work2d_ad(:, :, 2) = work2d_ad(:, :, 2) + ps_inc_ad + psfc_ad
     psfc_ad = 0.0_r_kind
     ts_ad = 0.0_r_kind
     tslv_ad = 0.0_r_kind
     CALL POPREAL4ARRAY(work2d(ims, jms, 2), r_kind*SIZE(p, 1)*SIZE(p, 2)/4)
     temp18 = rd*(ts+tslv)
     temp17 = fp_two*grav*hgt
     temp16 = temp17/temp18
     temp15 = EXP(temp16)
     temp15_ad = rd*temp16*EXP(temp16)*work2d(:, :, 1)*work2d_ad(:, :, 2)&
          /(temp18*temp15**2)
     work2d_ad(:, :, 1) = work2d_ad(:, :, 1) + work2d_ad(:, :, 2)/temp15
     work2d_ad(:, :, 2) = 0.0_r_kind
     pslv_ad = 0.0_r_kind
     CALL APPLY_DISP_2D_AD(pslv, fcadisp, work2d_ad(:, :, 1), fcadisp_ad, interp_order)
     temp14 = rd*(ts+tslv)
     temp13 = fp_two*grav*hgt
     temp12 = temp13/temp14
     temp12_ad = -(rd*temp12*EXP(temp12)*psfc*pslv_ad/temp14)
     tslv_ad = temp12_ad + temp15_ad
     zl_ad = 0.0_r_kind
     zl_ad = gamma*tslv_ad
     tm_ad = 0.0_r_kind
     temp11 = (psfc-p100mbPa)/psfc
     tm_ad = -(LOG(temp11)*rd*zl_ad/grav)
     ts_ad = temp12_ad + tm_ad/fp_two + temp15_ad
     temp11_ad = -(tm*rd*zl_ad/(psfc*temp11*grav))
     temp10 = rd*gamma/grav
     temp9 = psfc/(psfc-p100mbPa)
     WHERE (temp9 <= 0.0_r_kind .AND. (temp10 == 0.0_r_kind .OR. temp10 /= INT(&
          temp10))) 
        temp9_ad = 0.0_r_kind
     ELSEWHERE
        temp9_ad = temp10*temp9**(temp10-1)*tbl*ts_ad/(psfc-p100mbPa)
     END WHERE
     psfc_ad = EXP(temp12)*pslv_ad + temp9_ad - temp9*temp9_ad + &
          temp11_ad - temp11*temp11_ad - ps_inc_ad
     tbl_ad = 0.0_r_kind
     tbl_ad = tm_ad/fp_two + temp9**temp10*ts_ad + tslv_ad
     
     DO i= ime, ims, -1
        DO j= jme, jms, -1
           DO k= kte-1, kts, -1
              CALL POPINTEGER4(branch)
              IF (branch < 4) THEN
                 IF (branch < 3) THEN
                    tk_ad(i, j, k+1) = tk_ad(i, j, k+1) + tbl_ad(i, j)
                    tbl_ad(i, j) = 0.0_r_kind
                 END IF
              ELSE
                 temp8 = ptot(i, j, k+1)
                 temp0 = ptot(i, j, k)/temp8
                 temp7 = LOG(temp0)
                 temp7_ad = tbl_ad(i, j)/temp7
                 temp6 = psfc(i, j) - p100mbPa
                 temp4 = ptot(i, j, k)/temp6
                 temp5 = LOG(temp4)
                 temp4_ad = tk(i, j, k+1)*temp7_ad/(temp4*temp6)
                 temp3 = ptot(i, j, k+1)
                 temp1 = (psfc(i, j)-p100mbPa)/temp3
                 temp2 = LOG(temp1)
                 temp1_ad = tk(i, j, k)*temp7_ad/(temp1*temp3)
                 temp0_ad = -((tk(i, j, k+1)*temp5+tk(i, j, k)*temp2)*&
                      temp7_ad/(temp7*temp0*temp8))
                 tk_ad(i, j, k+1) = tk_ad(i, j, k+1) + temp5*temp7_ad
                 ptot_ad(i, j, k) = ptot_ad(i, j, k) + temp0_ad + temp4_ad
                 psfc_ad(i, j) = psfc_ad(i, j) + temp1_ad - temp4*temp4_ad
                 tk_ad(i, j, k) = tk_ad(i, j, k) + temp2*temp7_ad
                 ptot_ad(i, j, k+1) = ptot_ad(i, j, k+1) - temp0*temp0_ad - &
                      temp1*temp1_ad
                 tbl_ad(i, j) = 0.0_r_kind
              END IF
           END DO
           CALL POPINTEGER4(branch)
           IF (.NOT.branch < 1) THEN
              tk_ad(i, j, kte) = tk_ad(i, j, kte) + tbl_ad(i, j)
              tbl_ad(i, j) = 0.0_r_kind
           END IF
        END DO
     END DO
  endif !(istep > 6) 
  
  IF (th_compute == 1) THEN
     CALL POPREAL4ARRAY(t(ims,jms,kms), r_kind*ISIZE3OFt*ISIZE1OFt*ISIZE2OFt/4)
     CALL DISPLACE_THETA_WRF_AD(t, t_ad, ph, ph_ad, phb, fcadisp, fcadisp_ad,&
          needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
  ELSE
     CALL POPREAL4ARRAY(t(ims,jms,kms), r_kind*ISIZE3OFt*ISIZE1OFt*ISIZE2OFt/4)
     CALL APPLY_VERT_AD(t, t_ad, 0, work2d, work2d_ad, fcadisp, fcadisp_ad, interp_order)
     ph_ad = 0.0_r_kind
  END IF
  
  temp = rd/cp
  t_ad(:,:,kts:kte) = t_ad(:,:,kts:kte) + (ptot(:,:,kts:kte)/p0)**temp*tk_ad(:,:,kts:kte)
  ptot_ad(:,:,kts:kte) = ptot_ad(:,:,kts:kte) + temp*(ptot(:,:,kts:kte)/p0)**(temp-1)*(t(:,:,kts:kte)+t0)*tk_ad(:,:,kts:kte)/p0
  p_ad(:,:,kts:kte) = p_ad(:,:,kts:kte) + ptot_ad(:,:,kts:kte)
#ifdef TRACE_USE
  if (trace_use) call da_trace_exit("adj_wrf_derived_ad")
#endif
END SUBROUTINE ADJ_WRF_DERIVED_AD

SUBROUTINE DISPLACE_THETA_WRF_AD(t, t_ad, ph, ph_ad, phb, fcadisp, fcadisp_ad,&
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: displace_theta_wrf_ad
!   prgmmr: Nehrkorn
!
! abstract: Displace potential temperature field while accounting for the environmental lapse rate
!
! program history log:
!
!   input argument list: 
!       t, t_ad
!       ph, phb, ph_ad
!       fcadisp			! displacement field generated by FCA routine
!       fcadisp_ad		! displacement field generated by FCA routine
!       num_glob_needed, needed_ij_in, needed_ij_out, index_in
!       needed_wgts_out
!       interp_order
!
!   output argument list:
!       t, t_ad
!       ph_ad
!       fcadisp_ad		! displacement field generated by FCA routine
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
     
  IMPLICIT NONE
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(INOUT) :: t
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: t_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme), INTENT(IN) :: ph, phb
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_ad
  type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
  type (fca_gridded_disp), intent(inout) :: fcadisp_ad		! displacement field generated by FCA routine
  integer(i_kind), intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
  real(r_kind), intent(in) :: needed_wgts_out(:,:)
  integer(i_kind), intent(in) :: interp_order
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_tot
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: ph_tot_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: tknew, znew, zlvl
  real(r_kind), DIMENSION(ims:ime, jms:jme, kms:kme) :: tknew_ad, znew_ad, zlvl_ad
  INTEGER(I_KIND) :: k

#ifdef TRACE_USE
  if (trace_use) call da_trace_entry("displace_theta_wrf_ad")
#endif
  !zero local _ad arrays:

  ph_tot_ad=0._r_kind
  tknew_ad = 0.0_r_kind
  znew_ad=0._r_kind
  zlvl_ad=0._r_kind

  ph_tot = ph + phb
  ! find vertical displacement of theta mass level   
  DO k=kts, kte
     zlvl(:, :, k) = (ph_tot(:, :, k)+ph_tot(:, :, k+1))/2_r_kind/grav
     CALL APPLY_DISP_2D(zlvl(:, :, k), znew(:, :, k), fcadisp,&
          needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
  END DO
  tknew_ad = t_ad
  t_ad = 0._r_kind
  CALL APPLY_DISP_THETA_AD(fcadisp, fcadisp_ad, t, zlvl, zlvl_ad, znew, znew_ad, &
       tknew_ad,&
       needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
  DO k=kte,kts,-1
     CALL APPLY_DISP_2D_AD(zlvl(:, :, k), fcadisp, znew_ad(:, :, k), fcadisp_ad, interp_order)
     ph_tot_ad(:, :, k) = ph_tot_ad(:, :, k) + zlvl_ad(:, :, k)/(2_r_kind*grav)
     ph_tot_ad(:, :, k+1) = ph_tot_ad(:, :, k+1) + zlvl_ad(:, :, k)/(2_r_kind*grav)
     zlvl_ad(:, :, k) = 0.0_r_kind
  END DO
  ph_ad = 0.0_r_kind
  ph_ad = ph_tot_ad
#ifdef TRACE_USE
  if (trace_use) call da_trace_exit("displace_theta_wrf_ad")
#endif
END SUBROUTINE DISPLACE_THETA_WRF_AD

SUBROUTINE APPLY_DISP_THETA_AD(fcadisp, fcadisp_ad, tk, zlvl, zlvl_ad, znew, znew_ad, tknew_ad, &
     needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: apply_disp_theta_ad
!   prgmmr: Nehrkorn
!
! abstract: apply displacements to the 3d theta field
!
! program history log:
!
!   input argument list: 
!       fcadisp			! displacement field generated by FCA routine
!       fcadisp_ad		! displacement field generated by FCA routine
!       znew, TK, zlvl          ! displaced (new) height values, original field, original height values
!       TK_ad ! displaced (new) height values, original field, original height values
!       num_glob_needed, needed_ij_in, needed_ij_out, index_in
!       needed_wgts_out
!       interp_order
!
!   output argument list:
!       fcadisp_ad		! displacement field generated by FCA routine
!       tknew, tknew_ad         ! displaced theta
!       znew_ad, TK_ad, zlvl_ad ! displaced (new) height values, original field, original height values
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block

  IMPLICIT NONE
  type (fca_gridded_disp), intent(in) :: fcadisp			! displacement field generated by FCA routine
  type (fca_gridded_disp), intent(inout) :: fcadisp_ad		! displacement field generated by FCA routine
  real(r_kind), DIMENSION(ims:ime,jms:jme,kts:kte), INTENT(IN) :: znew, tk, zlvl
  real(r_kind), DIMENSION(ims:ime,jms:jme,kts:kte), intent(out) :: znew_ad, zlvl_ad
  real(r_kind), DIMENSION(ims:ime,jms:jme,kts:kte), intent(inout) :: tknew_ad
  integer(i_kind), intent(in) :: num_glob_needed, needed_ij_in(:,:), needed_ij_out(:,:), index_in(:)
  real(r_kind), intent(in) :: needed_wgts_out(:,:)
  integer(i_kind), intent(in) :: interp_order
  INTEGER(I_KIND) :: i, j, k, l
  INTEGER(I_KIND) :: ibot, itop
  ! theta above and below level for interpolation
  real(r_kind), DIMENSION(SIZE(tk, 1), SIZE(tk, 2), 2) :: t_bot_top
  real(r_kind), DIMENSION(SIZE(tk, 1), SIZE(tk, 2), 2) :: t_bot_top_ad

#ifdef TRACE_USE
  if (trace_use) call da_trace_entry("apply_disp_theta_ad")
#endif

  t_bot_top_ad = 0.0_r_kind
  ! initialize TKnew as missing
  itop = 2
  ! Compute new theta at top level:
  call apply_disp_2d(TK(:,:,kte),T_bot_top(:,:,itop),fcadisp, &
       needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)
  ! to ensure the bottom temperature ends in ibot=1 after switch at top of loop:
  itop = 1 

  DO l=kte-1,kts,-1
     ! switch top and bottom index
     ibot = itop
     IF (ibot == 1) THEN
        itop = 2
     ELSE
        itop = 1
     END IF
     ! Compute new theta at bottom level: now have nlm values where we need them (bot, top)
     ! Note this is done opposite from the NLM, since we are looping backwards in the adjoint
     ! However, just as in the NLM, l is in ibot, l+1 is in itop
     call apply_disp_2d(TK(:,:,l),T_bot_top(:,:,ibot),fcadisp, &
          needed_ij_in, needed_ij_out, index_in, needed_wgts_out, num_glob_needed, interp_order)

     DO k=kts, kte
        ! Adjoint of vertical interpolation: distributes tknew_ad to t_bot_top_ad
        WHERE (zlvl(:, :, k) > znew(:, :, l) .AND. zlvl(:, :, k) <=&
             znew(:, :, l+1)) 
           ! Linearly interpolate vertically between bottom and top levels
           t_bot_top_ad(:, :, itop) = t_bot_top_ad(:, :, itop) + &
                tknew_ad(:, :, k)*(zlvl(:, :, k)-znew(:, :, l))/&
                (znew(:, :, l+1)-znew(:, :, l))
           zlvl_ad(:, :, k) = zlvl_ad(:, :, k) + &
                tknew_ad(:, :, k)*(t_bot_top(:, :, itop)-t_bot_top(:, :, ibot))/&
                (znew(:, :, l+1)-znew(:, :, l))
           znew_ad(:, :, l) = znew_ad(:, :, l) - &
                tknew_ad(:, :, k)*((t_bot_top(:, :, itop)-t_bot_top(:, :, ibot))/&
                (znew(:, :, l+1)-znew(:, :, l)) &
                - (t_bot_top(:, :, itop)-t_bot_top(:, :, ibot))*(zlvl(:, :, k)-znew(:, :, l))/&
                (znew(:, :, l+1)-znew(:, :, l))**2)
           znew_ad(:, :, l+1) = znew_ad(:, :, l+1) - &
                tknew_ad(:, :, k)*(t_bot_top(:, :, itop)-t_bot_top(:, :, ibot))*(zlvl(:, :, k)-znew(:, :, l))/&
                (znew(:, :, l+1)-znew(:, :, l))**2
           t_bot_top_ad(:, :, ibot) = t_bot_top_ad(:, :, ibot) + &
                tknew_ad(:, :, k)*(1-(zlvl(:, :, k)-znew(:, :, l)) / &
                (znew(:, :, l+1)-znew(:, :, l)))
           tknew_ad(:, :, k) = 0.0_r_kind
        end WHERE

        IF (l == 1) THEN
           WHERE (zlvl(:, :, k) <= znew(:, :, l)) 
              ! For grid points with height at or below bottom-most znew (origin) level:
              t_bot_top_ad(:, :, ibot) = t_bot_top_ad(:, :, ibot) + &
                   tknew_ad(:, :, k)
              tknew_ad(:, :, k) = 0.0_r_kind
           end WHERE
        ELSE IF (l == kte - 1) THEN
           WHERE (zlvl(:, :, k) >= znew(:, :, l+1)) 
              ! For grid points with new height at or above top-most level:
              t_bot_top_ad(:, :, itop) = t_bot_top_ad(:, :, itop) + &
                   tknew_ad(:, :, k)
              tknew_ad(:, :, k) = 0.0_r_kind
           end WHERE
        END IF
     END DO
     ! Adjoint of l+1 displacement: transfers t_bot_top_ad(itop) to fcadisp_ad
     CALL APPLY_DISP_2D_AD(tk(:, :, l+1), fcadisp, t_bot_top_ad(:, :, itop), fcadisp_ad, interp_order)
     t_bot_top_ad(:, :, itop) = 0._r_kind
  END DO

  ! Adjoint of l=1 displacement: transfers t_bot_top_ad(ibot) to fcadisp_ad
  CALL APPLY_DISP_2D_AD(tk(:, :, 1), fcadisp, t_bot_top_ad(:, :, ibot), fcadisp_ad, interp_order)
  t_bot_top_ad(:, :, ibot) = 0._r_kind

#ifdef TRACE_USE
  if (trace_use) call da_trace_exit("apply_disp_theta_ad")
#endif

END SUBROUTINE APPLY_DISP_THETA_AD

SUBROUTINE SH2RH_AD0(hum, hum_ad, t, t_ad, parr, parr_ad, sh2rh_ad)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: sh2rh_ad
!   prgmmr: Nehrkorn
!
! abstract: Convert mixing ratio (kg/kg) to relative humidity (%)
!           ! Formulas and constants from WRFV3.2.1 (module_initialize_real.F, Registry.EM)
!
! program history log:
!
!   input argument list: 
!    hum, hum_ad - mixing ratio (kg/kg)
!    t, t_ad - temperature (K)
!    parr,parr_ad - pressure (Pa)
!    sh2rh, sh2rh_ad
!
!   output argument list:
!    hum_ad - mixing ratio (kg/kg)
!    t_ad - temperature (K)
!    parr_ad - pressure (Pa)
!    sh2rh, sh2rh_ad
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
  IMPLICIT NONE
  real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: hum, t, parr
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: hum_ad, t_ad, parr_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: sh2rh
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: sh2rh_ad
  INTEGER(I_KIND) :: i, j
  real(r_kind) :: r, e, esat, p
  real(r_kind) :: r_ad, e_ad, esat_ad, p_ad
  real(r_kind) :: rdorv, ew, t1
  real(r_kind) :: ew_ad, t1_ad
  ! From module_intialize_real.F:
  real(r_kind), PARAMETER :: t_ref=0.0_r_kind
  real(r_kind), PARAMETER :: mw_air=28.966_r_kind
  real(r_kind), PARAMETER :: mw_vap=18.0152_r_kind
  real(r_kind), PARAMETER :: a0=6.107799961_r_kind
  real(r_kind), PARAMETER :: a1=4.436518521e-01_r_kind
  real(r_kind), PARAMETER :: a2=1.428945805e-02_r_kind
  real(r_kind), PARAMETER :: a3=2.650648471e-04_r_kind
  real(r_kind), PARAMETER :: a4=3.031240396e-06_r_kind
  real(r_kind), PARAMETER :: a5=2.034080948e-08_r_kind
  real(r_kind), PARAMETER :: a6=6.136820929e-11_r_kind
  real(r_kind), PARAMETER :: es0=6.1121_r_kind
  real(r_kind), PARAMETER :: c1=9.09718_r_kind
  real(r_kind), PARAMETER :: c2=3.56654_r_kind
  real(r_kind), PARAMETER :: c3=0.876793_r_kind
  real(r_kind), PARAMETER :: eis=6.1071_r_kind
  real(r_kind) :: rhs
  real(r_kind) :: rhs_ad
  real(r_kind), PARAMETER :: tf=273.16_r_kind
  real(r_kind),         parameter     :: const_47 = -47._r_kind
  real(r_kind),         parameter     :: const_17 = 17.67_r_kind
  real(r_kind),         parameter     :: const_10 = 10._r_kind
  real(r_kind),         parameter     :: const_100 = 100._r_kind
  real(r_kind),         parameter     :: const_243 = 243.5_r_kind
  real(r_kind) :: tk
  real(r_kind) :: tk_ad
  INTEGER(I_KIND) :: branch
  real(r_kind) :: temp0_ad
  real(r_kind) :: temp1
  real(r_kind) :: temp0
  INTRINSIC EXP
  real(r_kind) :: temp1_ad
  real(r_kind) :: temp2_ad
  INTRINSIC SIZE
  real(r_kind) :: temp_ad0
  real(r_kind) :: temp_ad
  INTRINSIC LOG10
  real(r_kind) :: temp
  rdorv = mw_vap/mw_air
  DO j= jms, jme
     DO i= ims, ime
        p = parr(i, j)
        r = hum(i, j)
        e = p*r/(rdorv+r)
        ! real formulas wrt liquid/ice:
        t1 = t(i, j) - tf
        IF (t1 >= t_ref .AND. t1 >= const_47) THEN
           ! liq phase eslo
           ew = a0 + t1*(a1+t1*(a2+t1*(a3+t1*(a4+t1*(a5+t1*a6)))))
           CALL PUSHINTEGER4(0)
        ELSE IF (t1 >= t_ref .AND. t1 < const_47) THEN
           !liq phas poor es
           ew = es0*EXP(const_17*t1/(t1+243.5_r_kind))
           CALL PUSHINTEGER4(1)
        ELSE
           tk = t(i, j)
           CALL PUSHREAL4ARRAY(rhs, r_kind/4)
           rhs = -(c1*(tf/tk-1.)) - c2*LOG10(tf/tk) + c3*(1.-tk/tf) + &
                LOG10(eis)
           ew = const_10**rhs
           CALL PUSHINTEGER4(2)
        END IF
        CALL PUSHREAL4ARRAY(esat, r_kind/4)
        ! factor of 100. to convert from mb (hPa) to Pa:
        esat = const_100*ew
        sh2rh(i, j) = const_100*e/esat
        IF (sh2rh(i, j) > const_100) THEN
           CALL PUSHINTEGER4(2)
        ELSE
           CALL PUSHINTEGER4(1)
        END IF
     END DO
  END DO
  DO j= jme, jms, -1
     DO i= ime, ims, -1
        CALL POPINTEGER4(branch)
        IF (.NOT.branch < 2) sh2rh_ad(i, j) = 0.0_r_kind
        p = parr(i, j)
        r = hum(i, j)
        e = p*r/(rdorv+r)
        temp2_ad = const_100*sh2rh_ad(i, j)/esat
        e_ad = temp2_ad
        esat_ad = -(e*temp2_ad/esat)
        sh2rh_ad(i, j) = 0.0_r_kind
        CALL POPREAL4ARRAY(esat, r_kind/4)
        ew_ad = const_100*esat_ad
        CALL POPINTEGER4(branch)
        IF (branch < 2) THEN
           IF (branch < 1) THEN
              t1 = t(i, j) - tf
              temp0 = a4 + t1*(a5+a6*t1)
              temp = a3 + t1*temp0
              temp0_ad = t1**2*ew_ad
              temp_ad0 = t1*temp0_ad
              t1_ad = (t1**2*a6+t1*(a5+a6*t1)+temp0)*temp_ad0 + temp*&
                   temp0_ad + (2*(t1*(a2+t1*temp))+a1)*ew_ad
           ELSE
              t1 = t(i, j) - tf
              temp1 = t1/(t1+243.5_r_kind)
              temp1_ad = es0*EXP(const_17*temp1)*const_17*ew_ad/(t1+243.5_r_kind)
              t1_ad = (1.0_r_kind-temp1)*temp1_ad
           END IF
        ELSE
           rhs_ad = const_10**rhs*LOG(const_10)*ew_ad
           tk = t(i, j)
           CALL POPREAL4ARRAY(rhs, r_kind/4)
           tk_ad = (c1*tf/tk**2+c2/(tk*LOG(const_10))-c3/tf)*rhs_ad
           t_ad(i, j) = t_ad(i, j) + tk_ad
           t1_ad = 0.0_r_kind
        END IF
        t_ad(i, j) = t_ad(i, j) + t1_ad
        temp_ad = e_ad/(rdorv+r)
        p_ad = r*temp_ad
        r_ad = (p-p*r/(rdorv+r))*temp_ad
        hum_ad(i, j) = hum_ad(i, j) + r_ad
        parr_ad(i, j) = parr_ad(i, j) + p_ad
     END DO
  END DO
END SUBROUTINE SH2RH_AD0

SUBROUTINE RH2SH_AD0(rh, rh_ad, t, t_ad, parr, parr_ad, rh2sh_ad)
!$$$  subprogram documentation block
!                .      .    .                                       .
! subprogram: rh2sh_ad
!   prgmmr: Nehrkorn
!
! abstract: Convert  relative humidity (%) to mixing ratio (kg/kg)
!           ! Formulas and constants from WRFV3.2.1 (module_initialize_real.F, Registry.EM)
!
! program history log:
!
!   input argument list: 
!    rh, rh_ad - relative humidity (%)
!    t, t_ad - temperature (K)
!    parr, parr_ad - pressure (Pa)
!    rh2sh, rh2sh_ad
!
!   output argument list:
!    rh_ad - relative humidity (%)
!    t_ad - temperature (K)
!    parr_ad - pressure (Pa)
!    rh2sh, rh2sh_ad
!
! attributes:
!   language: f90
!   machine:
!
!$$$ end documentation block
  IMPLICIT NONE
  real(r_kind), DIMENSION(ims:ime, jms:jme), INTENT(IN) :: rh, t, parr
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: rh_ad, t_ad, parr_ad
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: rh2sh
  real(r_kind), DIMENSION(ims:ime, jms:jme) :: rh2sh_ad
  INTEGER(I_KIND) :: i, j
  real(r_kind) :: e, esat, p
  real(r_kind) :: e_ad, esat_ad, p_ad
  real(r_kind) :: rdorv, ew, t1
  real(r_kind) :: ew_ad, t1_ad
  ! From module_intialize_real.F:
  real(r_kind), PARAMETER :: t_ref=0.0_r_kind
  real(r_kind), PARAMETER :: mw_air=28.966_r_kind
  real(r_kind), PARAMETER :: mw_vap=18.0152_r_kind
  real(r_kind), PARAMETER :: a0=6.107799961_r_kind
  real(r_kind), PARAMETER :: a1=4.436518521e-01_r_kind
  real(r_kind), PARAMETER :: a2=1.428945805e-02_r_kind
  real(r_kind), PARAMETER :: a3=2.650648471e-04_r_kind
  real(r_kind), PARAMETER :: a4=3.031240396e-06_r_kind
  real(r_kind), PARAMETER :: a5=2.034080948e-08_r_kind
  real(r_kind), PARAMETER :: a6=6.136820929e-11_r_kind
  real(r_kind), PARAMETER :: es0=6.1121_r_kind
  real(r_kind), PARAMETER :: c1=9.09718_r_kind
  real(r_kind), PARAMETER :: c2=3.56654_r_kind
  real(r_kind), PARAMETER :: c3=0.876793_r_kind
  real(r_kind), PARAMETER :: eis=6.1071_r_kind
  real(r_kind) :: rhs
  real(r_kind) :: rhs_ad
  real(r_kind), PARAMETER :: tf=273.16_r_kind
  real(r_kind),         parameter     :: const_47 = -47._r_kind
  real(r_kind),         parameter     :: const_17 = 17.67_r_kind
  real(r_kind),         parameter     :: const_10 = 10._r_kind
  real(r_kind),         parameter     :: const_100 = 100._r_kind
  real(r_kind),         parameter     :: const_243 = 243.5_r_kind
  real(r_kind) :: tk
  real(r_kind) :: tk_ad
  INTEGER(I_KIND) :: branch
  real(r_kind) :: temp0_ad
  real(r_kind) :: temp1
  real(r_kind) :: temp0
  INTRINSIC EXP
  real(r_kind) :: temp1_ad
  real(r_kind) :: temp2_ad0
  real(r_kind) :: temp2_ad
  INTRINSIC SIZE
  real(r_kind) :: temp_ad
  INTRINSIC LOG10
  real(r_kind) :: temp
  rdorv = mw_vap/mw_air
  DO j= jms, jme
     DO i= ims, ime
        ! real formulas wrt liquid/ice:
        t1 = t(i, j) - tf
        IF (t1 >= t_ref .AND. t1 >= const_47) THEN
           ! liq phase eslo
           ew = a0 + t1*(a1+t1*(a2+t1*(a3+t1*(a4+t1*(a5+t1*a6)))))
           CALL PUSHINTEGER4(0)
        ELSE IF (t1 >= t_ref .AND. t1 < const_47) THEN
           !liq phas poor es
           ew = es0*EXP(const_17*t1/(t1+243.5_r_kind))
           CALL PUSHINTEGER4(1)
        ELSE
           tk = t(i, j)
           CALL PUSHREAL4ARRAY(rhs, r_kind/4)
           rhs = -(c1*(tf/tk-1.)) - c2*LOG10(tf/tk) + c3*(1.-tk/tf) + &
                LOG10(eis)
           ew = const_10**rhs
           CALL PUSHINTEGER4(2)
        END IF
        CALL PUSHREAL4ARRAY(esat, r_kind/4)
        ! factor of 100. to convert from mb (hPa) to Pa
        esat = const_100*ew
        ! total pressure
        ! vapor pressure ; scale percent RH to decimal
        ! mixing ratio
     END DO
  END DO
  DO j= jme, jms, -1
     DO i= ime, ims, -1
        e = esat*rh(i, j)/const_100
        p = parr(i, j)
        temp2_ad = rdorv*rh2sh_ad(i, j)/(p-e)
        temp2_ad0 = -(e*temp2_ad/(p-e))
        e_ad = temp2_ad - temp2_ad0
        p_ad = temp2_ad0
        rh2sh_ad(i, j) = 0.0_r_kind
        esat_ad = rh(i, j)*e_ad/const_100
        rh_ad(i, j) = rh_ad(i, j) + esat*e_ad/const_100
        parr_ad(i, j) = parr_ad(i, j) + p_ad
        CALL POPREAL4ARRAY(esat, r_kind/4)
        ew_ad = const_100*esat_ad
        CALL POPINTEGER4(branch)
        IF (branch < 2) THEN
           IF (branch < 1) THEN
              t1 = t(i, j) - tf
              temp0 = a4 + t1*(a5+a6*t1)
              temp = a3 + t1*temp0
              temp0_ad = t1**2*ew_ad
              temp_ad = t1*temp0_ad
              t1_ad = (t1**2*a6+t1*(a5+a6*t1)+temp0)*temp_ad + temp*&
                   temp0_ad + (2*(t1*(a2+t1*temp))+a1)*ew_ad
           ELSE
              t1 = t(i, j) - tf
              temp1 = t1/(t1+243.5_r_kind)
              temp1_ad = es0*EXP(const_17*temp1)*const_17*ew_ad/(t1+243.5_r_kind)
              t1_ad = (1.0_r_kind-temp1)*temp1_ad
           END IF
        ELSE
           rhs_ad = const_10**rhs*LOG(const_10)*ew_ad
           tk = t(i, j)
           CALL POPREAL4ARRAY(rhs, r_kind/4)
           tk_ad = (c1*tf/tk**2+c2/(tk*LOG(const_10))-c3/tf)*rhs_ad
           t_ad(i, j) = t_ad(i, j) + tk_ad
           t1_ad = 0.0_r_kind
        END IF
        t_ad(i, j) = t_ad(i, j) + t1_ad
     END DO
  END DO
END SUBROUTINE RH2SH_AD0

#ifdef FCA_REF_MOD
end module displace_wrf_ad_m
#endif
